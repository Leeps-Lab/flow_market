{% extends "global/Page.html" %}
{% load staticfiles otree_tags %}

{% block title %}
    Flow Market
{% endblock %}

{% block content %}
<style>
	table {
		border-collapse: collapse;
		width: 90%;
	}
	td, th {
		border: 1px solid #dddddd;
		text-align: left;
		padding: 8px;
	}
	.border {
	  border-radius: 25px;
	  border: 2px solid;
	  padding: 20px;
      margin: 5px;
	}
</style>
    <div id="container" style="display:flex;">
        <div id="left" style="display:flex;flex-direction:column;width:500px;">
            <div class="border">
                <h1>Info</h1>
                <h3>Round {{subsession.round_number}}</h3>
                <h3>Bets </h3>
                <table>
                    <tr> 
                        <th>Direction </th>
                        <th>Price </th>
                        <th>Quantity </th>
                        <th>Deadline </th>
                    </tr>
                    {% for bet in bets %}
                        <tr> 
                            <td>{{bet.direction}} </td>
                            <td>{{bet.limit_price}} </td>
                            <td>{{bet.quantity}} </td>
                            <td>{{bet.deadline}} ms</td>
                        </tr>
                    {% endfor %}
                </table>
                <div style="display:flex;flex-direction: row;">
                    <P >Cash: <span id="cashInfo">{{player.cash}}</span></P>
                    <P style="padding-left:50px;">Inventory: <span id="invInfo">{{player.inventory}}</span></P>
                </div>
                
            </div>
            <div class="border">
                <h2>Manual Input</h2>
                <input type="range" min="1" max="{{max_price}}" value="10" class="slider" id="minpriceSlider"> 
                    <span id="minpriceValue" style="float: left; width: 100px;"></span><br><br>

                <input type="range" min="1" max="{{max_price}}" value="10" class="slider" id="maxpriceSlider">
                    <span id="maxpriceValue" style="float: left; width: 100px;"></span><br><br>

                <input type="range" min="1" max="{{max_q_max}}" value="50" class="slider" id="volSlider">
                    <span id="volValue" style="float: left; width: 100px;"></span><br><br>

                <input type="range" min="1.0" max="{{max_u_max}}" value="2.50" class="slider" id="rateSlider"> 
                    <span id="rateValue" style="float: left; width: 100px;"></span><br><br>

                <button type="button" id="sendBid" onclick="new_buy()" style="background-color: #008CBA;">Send Buy</button>
                <button type="button" id="sendAsk" onclick="new_sell()" style="background-color: #f44336;">Send Sell</button>
            </div>

            <div class="border">
                <h2>Algorithmic Input</h2>
                <input type="range" min="2" max="20" value="10" class="slider" id="algo-timeSlider"> 
                    <span id="algo-timeValue" style="float: left; width: 100px;"></span><br><br>
                
                <input type="range" min="1" max="10" value="5" class="slider" id="algo-quantitySlider"> 
                    <span id="algo-quantityValue" style="float: left; width: 100px;"></span><br><br>

                <input type="range" min="1" max="{{max_price}}" value="10" class="slider" id="algo-minpriceSlider"> 
                    <span id="algo-minpriceValue" style="float: left; width: 100px;"></span><br><br>

                <input type="range" min="1" max="{{max_price}}" value="10" class="slider" id="algo-maxpriceSlider">
                    <span id="algo-maxpriceValue" style="float: left; width: 100px;"></span><br><br>

                <input type="range" min="1" max="{{max_q_max}}" value="50" class="slider" id="algo-volSlider">
                    <span id="algo-volValue" style="float: left; width: 100px;"></span><br><br>

                <input type="range" min="1.0" max="{{max_u_max}}" value="2.50" class="slider" id="algo-rateSlider"> 
                    <span id="algo-rateValue" style="float: left; width: 100px;"></span><br><br>

                <button type="button" id="algo-sendBid" onclick="new_buy_algo()" style="background-color: #008CBA;">Send Buy</button>
                <button type="button" id="algo-sendAsk" onclick="new_sell_algo()" style="background-color: #f44336;">Send Sell</button>
            </div>
        </div>

        <div id="right" style="display:flex;flex-direction:column;width:500px;">
                <div class="wrapper"><canvas id="klf-line"></canvas></div>    
                <div class="wrapper" style="flex:50%"><div id="cash-bar" width=""></div></div>
                <div class="wrapper" style="flex:50%"><div id="inv-bar" width=""></div></div>
        </div>
    </div>

    
{% endblock %}
{% block scripts %}
<!--
    Code heavily adopted from Jason Vranek (github.com/JasonVranek)
-->
<script type="module" src="{% static 'flow_market/market.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
<script src="https://code.highcharts.com/highcharts.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        if({{player.id_in_group}} == 1){
            liveSend({'direction': 'begin'});
            console.log("begin round");
        }
        
    }, false);


    function init_graphs() {
        var cash_ctx = document.getElementById('cash-bar');
        var cash_bar = Highcharts.chart('cash-bar', {

            title: {
                text: 'Cash'
            },

            yAxis: {
                title: {
                    text: 'Cash'
                }
            },

            xAxis: {
                title: {
                    text: 'Units'
                }
            },

            legend: {
                layout: 'vertical',
                align: 'right',
                verticalAlign: 'middle'
            },

            plotOptions: {
                series: {
                    label: {
                        connectorAllowed: false
                    },
                    marker: {
                        enabled: false
                    }
                }
            },

            series: [{
                name: 'Cash',
                data: [{{player.cash}}]
            }],

            responsive: {
                rules: [{
                    condition: {
                        maxWidth: 500
                    }
                }]
            }

        });
        

        var inv_ctx = document.getElementById('inv-bar');
        var inventory_bar = Highcharts.chart('inv-bar', {

            title: {
                text: 'Inventory'
            },

            yAxis: {
                title: {
                    text: 'Units'
                }
            },

            xAxis: {

            },

            legend: {
                layout: 'vertical',
                align: 'right',
                verticalAlign: 'middle'
            },

            plotOptions: {
                series: {
                    label: {
                        connectorAllowed: false
                    },
                    marker: {
                        enabled: false
                    }
                }
            },

            series: [{
                name: 'Inventory',
                data: [{{player.inventory}}]
            }],

            responsive: {
                rules: [{
                    condition: {
                        maxWidth: 500
                    }
                }]
            }

        });

        var klf_line_ctx = document.getElementById('klf-line');	
        var klf_line = new Chart(klf_line_ctx, {
            type: 'scatter',
            options: {
                scales: {
                    yAxes: [{
                        ticks: {
                            // beginAtZero: true,
                        },
                    }]
                },
                title: {
                    display: true,
                    text: 'Market',
                }, 
                elements: {
                    point: {
                        radius: 3,
                        pointStyle: 'dash',
                    },
                },
            },
            data: {
                datasets: [{
                    label: 'Bids',
                    borderColor: "#0000fe",
                    backgroundColor: 'rgba(0, 0, 0, 0)',	
                    fill: false,
                    showLine: true,
                    lineTension: 0,
                    data: [],
                }, {
                    label: 'Asks',
                    borderColor: "#fb0009",
                    backgroundColor: 'rgba(0, 0, 0, 0)',	
                    fill: false,
                    showLine: true,
                    lineTension: 0,
                    data: [],
                }, {
                    label: 'Clearing Price',
                    borderColor: "#55d22e",
                    backgroundColor: 'rgba(0, 0, 0, 0)',	
                    fill: false,
                    showLine: true,
                    lineTension: 0,
                    data: [],
                }]
            },
        });

        return [cash_bar, inventory_bar, klf_line];
    }

    let graphs = init_graphs();
    let klf_line = graphs[2];
    let cash_bar = graphs[0];
    let inventory_bar = graphs[1];

    // Initialize the UI elements
    var minpriceSlider = document.getElementById("minpriceSlider");
    var minpriceValue = document.getElementById("minpriceValue");
    var volSlider = document.getElementById("volSlider");
    var volValue = document.getElementById("volValue");
    var rateSlider = document.getElementById("rateSlider");
    var rateValue = document.getElementById("rateValue");
    var maxpriceSlider = document.getElementById("maxpriceSlider");
    var maxpriceValue = document.getElementById("maxpriceValue");

    minpriceSlider.value = 10;
    minpriceValue.innerHTML = "Min Price: " + minpriceSlider.value;

    volSlider.value = 50;
    volValue.innerHTML = "Max Volume: " + volSlider.value;

    rateSlider.value = 3;
    rateValue.innerHTML = "Max Rate: " + rateSlider.value;

    maxpriceSlider.value = 10;
    maxpriceValue.innerHTML = "Max Price: " + maxpriceSlider.value;


    minpriceSlider.oninput = function() {
        minpriceValue.innerHTML = "Min Price: " + this.value;
    }

    volSlider.oninput = function() {
        volValue.innerHTML = "Max Volume: " + this.value;
    }

    rateSlider.oninput = function() {
        rateValue.innerHTML = "Max Rate: " + this.value;
    }

    maxpriceSlider.oninput = function() {
        maxpriceValue.innerHTML = "Max Price: " + this.value;
    }

    {% comment %} if('{{treatment}}' != 'flo'){
        // DONE code needed?, these elements are already removed in another if statement
        rateSlider.remove();
        rateValue.remove();
    } {% endcomment %}

    var algo_minpriceSlider = document.getElementById("algo-minpriceSlider");
    var algo_minpriceValue = document.getElementById("algo-minpriceValue");
    var algo_volSlider = document.getElementById("algo-volSlider");
    var algo_volValue = document.getElementById("algo-volValue");
    var algo_rateSlider = document.getElementById("algo-rateSlider");
    var algo_rateValue = document.getElementById("algo-rateValue");
    var algo_maxpriceSlider = document.getElementById("algo-maxpriceSlider");
    var algo_maxpriceValue = document.getElementById("algo-maxpriceValue");
    var algo_timeSlider = document.getElementById("algo-timeSlider");
    var algo_timeValue = document.getElementById("algo-timeValue");
    var algo_quantitySlider = document.getElementById("algo-quantitySlider");
    var algo_quantityValue = document.getElementById("algo-quantityValue");

    algo_minpriceSlider.value = 10;
    algo_minpriceValue.innerHTML = "Min Price: " + algo_minpriceSlider.value;

    algo_volSlider.value = 50;
    algo_volValue.innerHTML = "Max Volume: " + algo_volSlider.value;

    algo_rateSlider.value = 3;
    algo_rateValue.innerHTML = "Max Rate: " + algo_rateSlider.value;

    algo_maxpriceSlider.value = 10;
    algo_maxpriceValue.innerHTML = "Max Price: " + algo_maxpriceSlider.value;

    algo_timeSlider.value = 3;
    algo_timeValue.innerHTML = "Expiration time: " + algo_timeSlider.value;

    algo_quantitySlider.value = 10;
    algo_quantityValue.innerHTML = "Units at a time: " + algo_quantitySlider.value;


    algo_minpriceSlider.oninput = function() {
        algo_minpriceValue.innerHTML = "Min Price: " + this.value;
    }

    algo_volSlider.oninput = function() {
        algo_volValue.innerHTML = "Max Volume: " + this.value;
    }

    algo_rateSlider.oninput = function() {
        algo_rateValue.innerHTML = "Max Rate: " + this.value;
    }

    algo_maxpriceSlider.oninput = function() {
        algo_maxpriceValue.innerHTML = "Max Price: " + this.value;
    }

    algo_timeSlider.oninput = function() {
        algo_timeValue.innerHTML = "Expiration time: " + this.value;
    }

    algo_quantitySlider.oninput = function() {
        algo_quantityValue.innerHTML = "Units at a time: " + this.value;
    }

    if('{{treatment}}' != 'flo'){
        // DONE are rateSlider and rateValue removed if treatment is cda/fba?
        // if treatment is cda/fba, then remove max rate slider 
        // if treatment is flo, have a max rate slider
        // this is for both the manual and the algorithmic input

        // Because cda and fba has a fixed u_max
        rateSlider.remove();
        rateValue.remove();
        algo_rateSlider.remove();
        algo_rateValue.remove();
    }

    function calcDemand(buy, price) {
        if (price <= buy.p_min) {
            if (buy.q_max < buy.u_max) {
                // Don't trade more than q_max
                return buy.q_max;
            }
            // Trade at max rate if p <= p_min
            return buy.u_max;
        } else if (price > buy.p_max) {
            // Don't trade if price is higher than max willingness to buy
            return 0.0;
        } else {
            // The price fell p_min < price < p_max
            let trade_vol = buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
            if (trade_vol > buy.q_max) {
                // Saturate to q_max if trade_vol will exceed q_max
                return buy.q_max;
            }
            return trade_vol;
        }
    }

    function calcSupply(sell, price) {
        if (price < sell.p_min) {
            // Don't trade if price is lower than min willingness to sell
            return 0.0;
        } else if (price >= sell.p_max) {
            if (sell.q_max < sell.u_max) {
                // Don't trade more than q_max 
                return sell.q_max;
            } 
            // Trade at max rate if p >= p_max
            return sell.u_max;
        } else {
            // The price fell p_min < price < p_max
            let trade_vol = sell.u_max + ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
            if (trade_vol > sell.q_max) {
                // Saturate to q_max if trade_vol will exceed q_max
                return sell.q_max;
            }
            return trade_vol;
        }
    }

    function graphClearingPrice(chart, price, buys, sells) {
        buys = buys.filter(buy => buy['status'] == 'active');
        sells = sells.filter(sell => sell['status'] == 'active');
        var agg_supply = 0.0; // agg_supply will be equal to agg_demand
        sells.forEach(function (sell, _index, _array) { 	
                agg_supply += calcSupply(sell, price);
        });
        var points = [];

        points.push({x: 0.0, y: agg_supply});
        points.push({x: price, y: agg_supply});
        points.push({x: price, y: 0.0});

        chart.data.datasets[2].data = points;
        chart.update();
    }

    
    function graphBids(chart, buys) {
        buys = buys.filter(buy => buy['status'] == 'active');
        if('{{treatment}}' != 'cda'){ // TEST changes
            // READ
            // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply 
            if (buys.length == 0) {
                chart.data.datasets[0].data = [];
                chart.update();
                return;
            }

            var points = [];

            // Generate range(70, 130) the domain based on sliders values
            // var prices = Array.from(new Array(0), (x,i) => i + 20);
            var prices = [...Array(20).keys()];
            prices.forEach(function (price, _index, _array) {
                var agg_supply = 0.0;
                buys.forEach(function (buy, _index, _array) { 	
                    agg_supply += calcDemand(buy, price);
                });
                points.push({x: price, y: agg_supply});
            });
        }else{
            // if treatment is cda, sort the buy orders, 
            buys.sort((a, b) => (a['p_max'] < b['p_max']) ? 1 : -1);
            var volume = 0.0;
			var points = [];

            buys.forEach(function (buy, _index, _array) { 
				// Graph (price, old_vol) -> (price, new_vol)
				points.push({x: buy['p_max'], y: volume});
				volume += buy['q_max'];
				points.push({x: buy['p_max'], y: volume});
			});

			// insert a horizontal line to 0 to show limit order
			points.push({x: 0.0, y: volume})
        }
    

        chart.data.datasets[0].data = points;
        chart.update();
    }

    function graphAsks(chart, sells) {
        sells = sells.filter(sell => sell['status'] == 'active');
        if('{{treatment}}' != 'cda'){ // TEST changes 
            // READ
            if (sells.length == 0) {
                chart.data.datasets[1].data = [];
                chart.update();
                return;
            }
                
            var points = [];
            var prices = [...Array(20).keys()];
            prices.forEach(function (price, _index, _array) {
                var agg_supply = 0.0;
                sells.forEach(function (sell, _index, _array) { 	
                    agg_supply += calcSupply(sell, price);
                });
                points.push({x: price, y: agg_supply});
            });        
        } else{
            sells.sort((a, b) => (a['p_max'] > b['p_max']) ? 1 : -1);
			var volume = 0.0;
			var points = [];
			sells.forEach(function (sell, _index, _array) { 
				// Graph (price, old_vol) -> (price, new_vol)
				points.push({x: sell['p_max'], y: volume});
				volume += sell['q_max'];
				points.push({x: sell['p_max'], y: volume});
			});

			// insert a horizontal line to max price = 130 to show limit order
			points.push({x: 20.0, y: volume})
        }


        chart.data.datasets[1].data = points;
        chart.update();
    }
    
    // adds to the player's profit
    function updateProfit(chart, profit) {
        //chart.data.datasets[0].data[0] = profit;
        let dataset = chart.series[0];
        dataset.addPoint(profit);
        //chart.update();
    }

    // Adds or subtracts volume to trader
    function updateVolume(chart, volume) {
        //chart.data.datasets[0].data[0] = volume;
        let dataset = chart.series[0];
        dataset.addPoint(volume);
        //chart.update();
    }


    let order_id = 1;

    function liveRecv(data){
        if(data['type'] == 'begin'){
            console.log("Round begin");
        }
        if(data['type'] == 'clear'){
            klf_line.data.datasets[2].data = [];
			klf_line.update();
        }
        if(data['type'] == 'buy' || data['type'] == 'sell' || data['type'] == 'regraph'){
            console.log(data);
            graphBids(klf_line, data['buys']);
			graphAsks(klf_line, data['sells']);
        }
        if(data['type'] == 'clearing_price'){
            console.log(data);
            global_clearing_price = data['clearing_price'];
            // READ
            if('{{treatment}}' != 'cda') graphClearingPrice(klf_line, data['clearing_price'], data['buys'], data['sells']); // TEST changes
            graphBids(klf_line, data['buys']);
			graphAsks(klf_line, data['sells']);
        }
        if(data['type'] == 'update'){
            console.log(data);
            document.getElementById("cashInfo").innerHTML = data['cash'];
            document.getElementById("invInfo").innerHTML = data['inventory'];
            updateProfit(cash_bar, data['cash']);
			updateVolume(inventory_bar, data['inventory']);
        }
    };
    
    
    
    function new_buy(){
        var minprice = parseInt(document.getElementById("minpriceSlider").value);
        var volume = parseInt(document.getElementById("volSlider").value);
        var maxprice = parseInt(document.getElementById("maxpriceSlider").value);
        var u_max;
        if('{{treatment}}' != 'flo'){ // use rate slider if flo
            u_max = parseInt({{max_u_max}});
        } else{
            u_max = parseInt(document.getElementById("rateSlider").value);
        }
        

        if(minprice > maxprice){
            alert("Minimum Price should be less than or equal to Maximum Price")
            return;
        }
        
        liveSend({
            'p_min': minprice,
            'p_max': maxprice,
            'q_max': volume,
            'u_max': u_max,
            'direction': 'buy',
            'status': 'active',
            'timestamp':performance.now()
        });
        order_id += 1;
    };

    function new_sell(){
        var minprice = parseInt(document.getElementById("minpriceSlider").value);
        var volume = parseInt(document.getElementById("volSlider").value);
        var maxprice = parseInt(document.getElementById("maxpriceSlider").value);
        var u_max;
        if('{{treatment}}' != 'flo'){ // use rate slider if flo
            u_max = parseInt({{max_u_max}});
        } else{
            u_max = parseInt(document.getElementById("rateSlider").value);
        }

        if(minprice > maxprice){
            alert("Minimum Price should be less than or equal to Maximum Price")
            return;
        }
        
        liveSend({
            'p_min': minprice,
            'p_max': maxprice,
            'q_max': volume,
            'u_max': u_max,
            'direction': 'sell',
            'status': 'active',
            'timestamp':performance.now()
        });

    };

    function new_buy_algo(){
        var minprice = parseInt(document.getElementById("algo-minpriceSlider").value);
        var volume = parseInt(document.getElementById("algo-volSlider").value);
        var maxprice = parseInt(document.getElementById("algo-maxpriceSlider").value);
        var time = parseInt(document.getElementById("algo-timeSlider").value);
        var quantity_per = parseInt(document.getElementById("algo-quantitySlider").value);
        var u_max;
        if('{{treatment}}' != 'flo'){ // use rate slider if flo
            u_max = parseInt({{max_u_max}});
        } else{
            u_max = parseInt(document.getElementById("algo-rateSlider").value);
        }
        

        if(minprice > maxprice){
            alert("Minimum Price should be less than or equal to Maximum Price")
            return;
        }
        
        liveSend({
            'p_min': minprice,
            'p_max': maxprice,
            'q_max': volume,
            'u_max': u_max,
            'expiration_time': time,
            'quantity_per': quantity_per,
            'direction': 'buy_algo',
            'status': 'active',
            'timestamp':performance.now()
        });
        order_id += 1;
    };

    function new_sell_algo(){
        var minprice = parseInt(document.getElementById("algo-minpriceSlider").value);
        var volume = parseInt(document.getElementById("algo-volSlider").value);
        var maxprice = parseInt(document.getElementById("algo-maxpriceSlider").value);
        var time = parseInt(document.getElementById("algo-timeSlider").value);
        var quantity_per = parseInt(document.getElementById("algo-quantitySlider").value);
        var u_max;
        if('{{treatment}}' != 'flo'){ // use rate slider if flo
            u_max = parseInt({{max_u_max}});
        } else{
            u_max = parseInt(document.getElementById("algo-rateSlider").value);
        }

        if(minprice > maxprice){
            alert("Minimum Price should be less than or equal to Maximum Price")
            return;
        }
        
        liveSend({
            'p_min': minprice,
            'p_max': maxprice,
            'q_max': volume,
            'u_max': u_max,
            'expiration_time': time,
            'quantity_per': quantity_per,
            'direction': 'sell_algo',
            'status': 'active',
            'timestamp':performance.now()
        });

    };
</script>

{% endblock %}

{% load otree %}

<!-- Code heavily adopted from Jason Vranek (github.com/JasonVranek) (https://people.ucsc.edu/~jvranek/flow_viz.html) -->
<!-- not sure market.js is even needed anymore -->
<script type="module" src="{% static 'flow_market/market.js' %}"></script>
<!-- prettier-ignore -->
{% block constants %} {% include Constants.scripts_constants_template %} {% endblock %}
<!-- prettier-ignore -->
{% block imports %} {% include Constants.scripts_imports_template %} {% endblock %}
<!-- prettier-ignore -->
{% block init_graphs %} {% include Constants.scripts_init_graphs_template %} {% endblock %}
<!-- pretter-ignore -->
{% block init_sliders %} {% include Constants.scripts_init_sliders_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block InputDropdown %} {% include Constants.scripts_InputDropdown_template %} {% endblock %}

<script>
  document.addEventListener(
    'DOMContentLoaded',
    function () {
      if ('{{player.id_in_group}}' == 1) {
        liveSend({
          direction: 'begin',
        });
        console.log('begin round');
      }

      InputDropdown.hideAlgorithmicInputDropdown();
    },
    false
  );

  let orderHistory = [];

  // update order history if an order has expired
  function updateOrderHistory(data) {
    orderHistory = orderHistory.filter((order) => {
      let arrayToSearch;
      if (order.direction === 'buy') arrayToSearch = data.buys;
      if (order.direction === 'sell') arrayToSearch = data.sells;
      if (arrayToSearch === undefined) console.error('updateOrderHistory()');

      const orderInData = arrayToSearch.find((orderInData) => {
        return orderInData.orderID === order.orderID;
      });

      // BUG orderInData is sometimes undefined, not sure if due to liveserver delay with orderHistory
      if (orderInData === undefined) {
        console.error('orderInData undefined', order);
      }

      if (orderInData === undefined || orderInData.status === 'expired') {
        // also remove from active orders table
        removeActiveOrderTable(order.orderID);
        return false;
      } else {
        return true;
      }
    });
  }

  // check if potential order does not conflict with any orders in orderHistory
  function isNewOrderValid(newOrder) {
    if (orderHistory.length === 0) return undefined;

    // cda/fba: can only buy when buy's p_max < sell's p_max
    // cda/fba: can only sell when sell's p_max > buy's p_max
    let numToBeValid;
    if (isCDA || isFBA) {
      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_max < minPrice ? order.p_max : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }

      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_max > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }
    }

    // flo: can only sell when p_min is > buy's p_max
    // flo: can only buy when p_max < sell's p_min
    if (isFLO) {
      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_min > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }

      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_min < minPrice ? order.p_min : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }
    }

    return numToBeValid;
  }

  Chart.defaults.global.defaultFontFamily = 'Nunito';

  const graphs = init_graphs();
  const klf_line = graphs[2];
  const cash_bar = graphs[0];
  const inventory_bar = graphs[1];

  const slider = createNoUiPriceSlider();
  const noUiVolSlider = createNoUiVolSlider();
  const noUiRateSlider = createNoUiRateSlider();

  const noUiAlgoTimeSlider = createNoUiAlgoTimeSlider();
  const noUiAlgoQuantitySlider = createNoUiAlgoQuantitySlider();
  const noUiAlgoPriceSlider = createNoUiAlgoPriceSlider();
  const noUiAlgoVolSlider = createnoUiAlgoVolSlider();
  const noUiAlgoRateSlider = createNoUiAlgoRateSlider();

  const [cashOdometer, invOdometer] = intializeOdometers();

  if ('{{treatment}}' != 'flo') {
    // Because cda and fba has a fixed u_max
    document.querySelector('.noUiRateSliderWrapper').remove();
    document.querySelector('.noUiAlgoRateSliderWrapper').remove();
  }

  function calcDemand(buy, price) {
    if (price <= buy.p_min) {
      if (buy.q_max < buy.u_max) {
        // Don't trade more than q_max
        return buy.q_max;
      }
      // Trade at max rate if p <= p_min
      return buy.u_max;
    } else if (price > buy.p_max) {
      // Don't trade if price is higher than max willingness to buy
      return 0.0;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
      if (trade_vol > buy.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return buy.q_max;
      }
      return trade_vol;
    }
  }

  function calcSupply(sell, price) {
    if (price < sell.p_min) {
      // Don't trade if price is lower than min willingness to sell
      return 0.0;
    } else if (price >= sell.p_max) {
      if (sell.q_max < sell.u_max) {
        // Don't trade more than q_max
        return sell.q_max;
      }
      // Trade at max rate if p >= p_max
      return sell.u_max;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        sell.u_max +
        ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
      if (trade_vol > sell.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return sell.q_max;
      }
      return trade_vol;
    }
  }

  function graphClearingPrice(chart, price, buys, sells) {
    buys = buys.filter((buy) => buy['status'] == 'active');
    sells = sells.filter((sell) => sell['status'] == 'active');
    var agg_supply = 0.0; // agg_supply will be equal to agg_demand
    sells.forEach(function (sell, _index, _array) {
      agg_supply += calcSupply(sell, price);
    });
    var points = [];
    points.push({
      x: 0.0,
      y: agg_supply,
    });
    points.push({
      x: price,
      y: agg_supply,
    });
    points.push({
      x: price,
      y: 0.0,
    });

    chart.data.datasets[2].data = points;
    chart.update();
  }

  function graphBids(chart, buys) {
    // console.log('graphBids() buys:', buys);
    buys = buys.filter((buy) => buy['status'] == 'active');
    if ('{{treatment}}' != 'cda') {
      // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply
      if (buys.length == 0) {
        chart.data.datasets[0].data = [];
        chart.update();
        return;
      }

      var points = [];

      // Generate range(70, 130) the domain based on sliders values
      // var prices = Array.from(new Array(0), (x,i) => i + 20);
      var prices = [...Array(20).keys()];
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        buys.forEach(function (buy, _index, _array) {
          agg_supply += calcDemand(buy, price);
        });
        // console.log('graphBids() plotting x:', price, 'y:', agg_supply);
        points.push({
          x: price,
          y: agg_supply,
        });
      });
    } else {
      // if treatment is cda, sort the buy orders,
      buys.sort((a, b) => (a['p_max'] < b['p_max'] ? 1 : -1));
      var volume = 0.0;
      var points = [];

      buys.forEach(function (buy, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: buy['p_max'],
          y: volume,
        });
        volume += buy['q_max'];
        points.push({
          x: buy['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to 0 to show limit order
      points.push({
        x: 0.0,
        y: volume,
      });
    }

    chart.data.datasets[0].data = points;
    chart.update();
  }

  function graphAsks(chart, sells) {
    sells = sells.filter((sell) => sell['status'] == 'active');
    if ('{{treatment}}' != 'cda') {
      if (sells.length == 0) {
        chart.data.datasets[1].data = [];
        chart.update();
        return;
      }

      var points = [];
      var prices = [...Array(20).keys()];
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        sells.forEach(function (sell, _index, _array) {
          agg_supply += calcSupply(sell, price);
        });
        // console.log('graphSells() plotting x:', price, 'y:', agg_supply);
        points.push({
          x: price,
          y: agg_supply,
        });
      });
      // console.log('graphSells() points', points);
    } else {
      sells.sort((a, b) => (a['p_max'] > b['p_max'] ? 1 : -1));
      var volume = 0.0;
      var points = [];
      sells.forEach(function (sell, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: sell['p_max'],
          y: volume,
        });
        volume += sell['q_max'];
        points.push({
          x: sell['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to max price = 130 to show limit order
      points.push({
        x: 20.0,
        y: volume,
      });
    }

    chart.data.datasets[1].data = points;
    chart.update();
  }

  // adds to the player's profit
  function updateProfit(chart, profit) {
    //chart.data.datasets[0].data[0] = profit;
    let dataset = chart.series[0];
    const profitFormatted = parseFloat(profit.toFixed(2));
    dataset.addPoint(profitFormatted);
    //chart.update();
  }

  // Adds or subtracts volume to trader
  function updateVolume(chart, volume) {
    //chart.data.datasets[0].data[0] = volume;
    let dataset = chart.series[0];
    const volumeFormated = parseFloat(volume.toFixed(2));
    dataset.addPoint(volumeFormated);
    //chart.update();
  }

  class BetsUI {
    static #currentBet = null;

    static updateBets(bet) {
      const id = bet.bet_id;
      console.log('removing betID:', id);
      this.#removeFromActive(id);
      this.#appendToExpired();
    }

    static #removeFromActive(id) {
      this.#currentBet = document.querySelector(`#a${id}`).cloneNode(true);
      document.querySelector(`#a${id}`).remove();
    }

    static #appendToExpired() {
      const table = document.querySelector('#executedBetsTable');
      table.appendChild(this.#currentBet);
    }
  }

  function liveRecv(data) {
    // console.timeEnd(`timing`);
    // console.time(`timing`);
    if (data['type'] == 'begin') {
      console.log('Round begin');
    }
    if (data['type'] == 'clear') {
      // update cash and inventory bar regardless
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      // clear book graph
      klf_line.data.datasets[2].data = [];
      klf_line.update();
    }
    // check if any orders in our orderHistory have expired
    // if so, then get rid of it
    if (data['type'] === 'regraph') {
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
      //   console.warn('should check if order has expired here', data);
      updateOrderHistory(data);
    }

    if (data['type'] == 'buy' || data['type'] == 'sell') {
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }
    if (data['type'] == 'clearing_price') {
      global_clearing_price = data['clearing_price'];
      if ('{{treatment}}' != 'cda') {
        // console.error('data: ', data);
        graphClearingPrice(
          klf_line,
          data['clearing_price'],
          data['buys'],
          data['sells']
        );
      }
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }
    if (data['type'] == 'bets update') {
      console.log('bet:', data);
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedData = data;
      BetsUI.updateBets(data['bet']);
      // updateCashAndInventoryDisplay(data);
    }
    if (data['type'] == 'update') {
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedData = data;
      // updateCashAndInventoryDisplay(data);
    }
  }

  // console.error(parseFloat('{{ player.inventory|floatformat:1 }}'.toFixed(2)));
  // console.error(
  //   typeof parseFloat('{{ player.inventory|floatformat:1 }}'.toFixed(2))
  // );
  let cachedData;
  function updateCashAndInventoryDisplay(data) {
    if (cachedData === undefined) return;
    cashOdometer.update(parseFloat(data['cash']).toFixed(2));
    invOdometer.update(parseFloat(data['inventory']).toFixed(2));
    // console.error(parseFloat(data['cash']).toFixed(2));
  }
  setInterval(() => updateCashAndInventoryDisplay(cachedData), 1000);

  function new_buy() {
    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
      );
    }

    const volume = parseInt(
      document.getElementById('noUiVolSlider').noUiSlider.get()
    );

    var u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiRateSlider').noUiSlider.get()
      );
    }

    if (minprice > maxprice) {
      alert('Minimum Price should be less than or equal to Maximum Price');
      return;
    }

    const order = {
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      direction: 'buy',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    const valueToBeat = isNewOrderValid(order); // undefined means order is valid
    if (valueToBeat === undefined) {
      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);
    } else {
      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
      }
      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });
    }
  }

  function new_sell() {
    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
      );
    }

    const volume = parseInt(
      document.getElementById('noUiVolSlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiRateSlider').noUiSlider.get()
      );
    }

    const order = {
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      direction: 'sell',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    const valueToBeat = isNewOrderValid(order); // undefined means order is good
    if (valueToBeat === undefined) {
      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);
    } else {
      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the price above ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the minimum price above ${valueToBeat}.`;
      }
      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });
    }
  }

  function new_buy_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'buy_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function new_sell_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'sell_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function debug() {
    console.log('update: {{update_freq}}');
    console.log('mindelta: {{min_price_delta}}');
  }

  function appendActiveOrdersTable(order) {
    // console.error('appendActiveOrdersTable: ', order);
    const table = document.querySelector('#activeOrdersTable');
    const newRow = document.createElement('tr');

    const direction = document.createElement('td');
    direction.innerHTML = order.direction === 'buy' ? 'Buy' : 'Sell';

    const price = document.createElement('td');
    price.innerHTML =
      order.p_min === order.p_max
        ? `${order.p_max}`
        : `${order.p_min}-${order.p_max}`;

    const quantity = document.createElement('td');
    quantity.innerHTML = order.q_max;

    if (isFLO) {
      const rate = document.createElement('td');
      rate.innerHTML = order.u_max;

      direction.style.width = '92px';
      price.style.width = '62px';
      quantity.style.width = '90px';
      rate.style.width = '59px';
      newRow.append(direction, price, quantity, rate);
    } else {
      direction.style.width = '91px';
      price.style.width = '61px';
      quantity.style.width = '88px';
      newRow.append(direction, price, quantity);
    }

    // since id's cannot start with number
    newRow.id = 'a' + order.orderID;
    const tableWrapper = document.querySelector('#activeOrdersTableWrapper');

    table.appendChild(newRow);
  }

  if (isCDA || isFBA) {
    hideRateColumnActiveOrdersTable();
  }

  function removeActiveOrderTable(orderID) {
    const rowCopy = document.querySelector(`#a${orderID}`).cloneNode(true);
    document.querySelector(`#a${orderID}`).remove();

    const table = document.querySelector('#executedOrdersTable');
    table.appendChild(rowCopy);
    console.log('removed and appended');
  }

  function hideRateColumnActiveOrdersTable() {
    document.querySelector('#activeOrdersRate').remove();
    document.querySelector('#activeOrdersDirection').style.width = '0';
  }
</script>

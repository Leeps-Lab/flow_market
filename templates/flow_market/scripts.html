{% load otree %}

<!-- Code heavily adopted from Jason Vranek (github.com/JasonVranek) (https://people.ucsc.edu/~jvranek/flow_viz.html) -->
<!-- not sure market.js is even needed anymore -->
<script type="module" src="{% static 'flow_market/market.js' %}"></script>
<!-- prettier-ignore -->
{% block constants %} {% include Constants.scripts_constants_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block imports %} {% include Constants.scripts_imports_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block init_graphs %} {% include Constants.scripts_init_graphs_template %}
{% endblock %}
<!-- pretter-ignore -->
{% block init_sliders %} {% include Constants.scripts_init_sliders_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block InputDropdown %} {% include Constants.scripts_InputDropdown_template %}
{% endblock %}

<script>
  console.error("new_sell should be available")

  // DEBUG tick count
  let tickCount = 0
  const ticks = []

  document.addEventListener(
    'DOMContentLoaded',
    () => {
      if ('{{player.id_in_group}}' == 1) {
        liveSend({
          direction: 'begin',
        });
        console.log('begin round');
      }

      InputDropdown.hideAlgorithmicInputDropdown();
      BetsUI.convertDeadlinesToSeconds();
      ProfitGraph.updateProfitLineFromUpcomingBet()

      setInterval(() => {

        // DEBUG tick count
        // ticks.push(tickCount)
        // const avg = ticks.reduce((acc, curr) => acc + curr) / ticks.length
        // console.log("ticks since last second:", tickCount, " avg:", avg.toFixed(2))
        // tickCount = 0

        updateCashAndInventoryDisplay(cachedDataForOdometer);
        BetsUI.decrementDeadlines();
      }, 1000);
    },
    false
  );

  let cash = 0
  let inventory = 0

  let orderHistory = [];

  // update order history if an order has expired
  function updateOrderHistory(data) {
    orderHistory = orderHistory.filter((order) => {
      let arrayToSearch;
      if (order.direction === 'buy') arrayToSearch = data.buys;
      if (order.direction === 'sell') arrayToSearch = data.sells;
      if (arrayToSearch === undefined) console.error('updateOrderHistory()');

      const orderInData = arrayToSearch.find((orderInData) => {
        return orderInData.orderID === order.orderID;
      });

      // BUG orderInData is sometimes undefined, not sure if due to liveserver delay with orderHistory
      if (orderInData === undefined) {
        console.error('orderInData undefined', order);
      }

      if (orderInData === undefined || orderInData.status === 'expired') {
        // remove from active orders table
        removeActiveOrderTable(order.orderID);

        // update profit graph
        ProfitGraph.addOrderData(orderInData)

        return false;
      } else {
        return true;
      }
    });
  }

  // check if potential order does not conflict with any orders in orderHistory
  function isNewOrderValid(newOrder) {
    if (orderHistory.length === 0) return undefined;

    // cda/fba: can only buy when buy's p_max < sell's p_max
    // cda/fba: can only sell when sell's p_max > buy's p_max
    let numToBeValid;
    if (isCDA || isFBA) {
      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_max < minPrice ? order.p_max : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }

      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_max > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }
    }

    // flo: can only sell when p_min is > buy's p_max
    // flo: can only buy when p_max < sell's p_min
    if (isFLO) {
      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_min > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }

      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_min < minPrice ? order.p_min : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }
    }

    return numToBeValid;
  }


  // axes.addEventListener("click", () => {
  //   // Redraw all of the graphs
  //   graphCDA(cda_line, cda_bids, cda_asks);
    
  //   if (klf_bids.length > 0 && klf_asks.length > 0) {
  //     var clearing_price = clearingPrice(klf_bids, klf_asks);

  //     graphClearingPrice(klf_line, clearing_price, klf_bids, klf_asks);
  //   }

  //   graphKLF(klf_line, klf_bids, klf_asks);
  // });

  ///////////////////////////////////////////////////////////////////////////////////

  var ctx = document.getElementById('myChart').getContext('2d');
  var myChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
      datasets: [
        {
          label: 'Orders',
          // barPercentage: 1,
          // categoryPercentage: 1,
          // data: [10, 20, 30, 40, 50, 60, 70],
          // data: [0, 5, 10, 15, 20, 50, 50, 50, 50, 50, 50, 50, 55, 60, 65, 70, 75, 90, 120, 150, 200, 250, 300, 325, 325, 325, 325, 325, 325, 325, 230, 230, 230, 230, 230, 230, 230, 230, 230, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83,],
          data: [],
          fill: { above: 'red', below: 'green', target: { value: 10 } },
          pointRadius: 0,
          borderWidth: 2,
          borderColor: 'blue',
        },
        {
          label: 'Profit Line',
          // data: [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50],
          data: [],
          fill: false,
          pointRadius: 0,
          borderWidth: 2,
          borderColor: '#0',
        },
      ]
    },
    options: {
      maintainAspectRatio: false,
      scales: {
        y: {
          suggestedMin: 50,
          suggestedMax: 100,
          title: {
            display: true,
            text: 'Price',
          },
          beginAtZero: true,
        },

        x: {
          title: {
            display: true,
            text: 'Quantity',
          },
          beginAtZero: true,
        },
      }
    }
  });

  class ProfitGraph {
    static chart = myChart
    static profitLineValue = 0
    static potentialProfit = 0
    static betDirection = ""

    static updateProfitLineFromUpcomingBet() {
      const betData = BetsUI.getUpcomingBetData()
      if (betData !== null) {
        const { quantity, price, direction } = betData

        this.profitLineValue = price
        this.betDirection = direction
        this.potentialProfit = 0

        ProfitGraph.setLabelsBasedOnBet(myChart, quantity, price, direction)
      }
    }

    static addOrderData(order) {
      // TODO add conditional for if order and bet are compatible to graph
      // if (order["direction"].includes("buy"))
      console.log("addorderinfo", order)
      const { executedProfit, executedVolume } = order
      const pricePerVol = Math.abs(executedProfit) / Math.abs(executedVolume)

      this.updatePotentialProfit(executedProfit, executedVolume, pricePerVol)

      console.log("* pricePerVol", pricePerVol)

      for (let i = 0; i < Math.abs(executedVolume); i++) {
        this.chart.data.datasets[0].data.push(pricePerVol)
        console.log("pushed", pricePerVol)
      }

      this.chart.update();
    }

    static updatePotentialProfit(executedProfit, executedVolume, pricePerVol) {
      if (pricePerVol < this.profitLineValue) {

        if (this.betDirection.includes("BUY")) {
          this.potentialProfit += Math.abs(executedProfit)

        } else if (this.betDirection.includes("SELL")) {
          this.potentialProfit -= Math.abs(executedProfit)
        }

      } else if (pricePerVol > this.profitLineValue) {

        if (this.betDirection.includes("BUY")) {
          this.potentialProfit -= Math.abs(executedProfit)

        } else if (this.betDirection.includes("SELL")) {
          this.potentialProfit += Math.abs(executedProfit)
        }
      }

      console.log("potentialProfit:", this.potentialProfit)
      document.querySelector(".potentialProfit").textContent = `potential profit: ${Math.round(this.potentialProfit)}`
    }

    static setLabelsBasedOnBet(chart, betQuantity, betPrice, betDirection) {
      // x-axis values (labels)
      const newLabels = []
      for (let i = 0; i <= betQuantity; i++) {
        newLabels.push(i)
      }
      chart.data.labels = newLabels

      const profitPriceLine = []
      for (let i = 0; i <= betQuantity; i++) {
        profitPriceLine.push(betPrice)
      }
      chart.data.datasets[1].data = profitPriceLine

      // set profit price line
      chart.data.datasets[0].fill.target.value = betPrice
      chart.options.scales.y.suggestedMax = betPrice

      if (betDirection.includes("BUY")) {
        console.log("below green for buy")
        chart.data.datasets[0].fill.above = "red"
        chart.data.datasets[0].fill.below = "green"
      } else if (betDirection.includes("SELL")) {
        console.log("below red for sell")
        chart.data.datasets[0].fill.above = "green"
        chart.data.datasets[0].fill.below = "red"
      } else {
        console.error("betDirection not recognized")
      }

      chart.update();
    }

    static removeData(chart) {
      chart.data.labels.pop();
      chart.data.datasets.forEach((dataset) => {
        dataset.data.pop();
      });
      chart.update();
    }
  }

  function debug() {
    // console.log("test")
    // addData(myChart, 3)
    // setLabelsBasedOnBet(myChart, Math.ceil(Math.random() * 20))
    ProfitGraph.updateProfitLineFromUpcomingBet()
  }

  ///////////////////////////////////////////////////////////////////////////////////

  const graphs = init_graphs();
  const klf_line = graphs[2];
  const cash_bar = graphs[0];
  const inventory_bar = graphs[1];

  const slider = createNoUiPriceSlider();
  const noUiVolSlider = createNoUiVolSlider();
  const noUiRateSlider = createNoUiRateSlider();

  const noUiAlgoTimeSlider = createNoUiAlgoTimeSlider();
  const noUiAlgoQuantitySlider = createNoUiAlgoQuantitySlider();
  const noUiAlgoPriceSlider = createNoUiAlgoPriceSlider();
  const noUiAlgoVolSlider = createnoUiAlgoVolSlider();
  const noUiAlgoRateSlider = createNoUiAlgoRateSlider();

  const [cashOdometer, invOdometer] = intializeOdometers();

  if ('{{treatment}}' != 'flo') {
    // Because cda and fba has a fixed u_max
    document.querySelector('.noUiRateSliderWrapper').remove();
    document.querySelector('.noUiAlgoRateSliderWrapper').remove();
  }

  function calcDemand(buy, price) {
    if (price <= buy.p_min) {
      if (buy.q_max < buy.u_max) {
        // Don't trade more than q_max
        return buy.q_max;
      }
      // Trade at max rate if p <= p_min
      return buy.u_max;
    } else if (price > buy.p_max) {
      // Don't trade if price is higher than max willingness to buy
      return 0.0;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
      if (trade_vol > buy.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return buy.q_max;
      }
      return trade_vol;
    }
  }

  function calcSupply(sell, price) {
    if (price < sell.p_min) {
      // Don't trade if price is lower than min willingness to sell
      return 0.0;
    } else if (price >= sell.p_max) {
      if (sell.q_max < sell.u_max) {
        // Don't trade more than q_max
        return sell.q_max;
      }
      // Trade at max rate if p >= p_max
      return sell.u_max;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        sell.u_max +
        ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
      if (trade_vol > sell.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return sell.q_max;
      }
      return trade_vol;
    }
  }

  function graphClearingPrice(chart, price, buys, sells) {
    buys = buys.filter((buy) => buy['status'] == 'active');
    sells = sells.filter((sell) => sell['status'] == 'active');
    var agg_supply = 0.0; // agg_supply will be equal to agg_demand
    sells.forEach(function (sell, _index, _array) {
      agg_supply += calcSupply(sell, price);
    });
    var points = [];
    points.push({
      x: 0.0,
      y: agg_supply,
    });
    points.push({
      x: price,
      y: agg_supply,
    });
    points.push({
      x: price,
      y: 0.0,
    });

    chart.data.datasets[2].data = points;
    chart.update();
  }

  function graphBids(chart, buys) {
    // console.log('graphBids() buys:', buys);
    buys = buys.filter((buy) => buy['status'] == 'active');
    if ('{{treatment}}' != 'cda') {
      // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply
      if (buys.length == 0) {
        chart.data.datasets[0].data = [];
        chart.update();
        return;
      }

      var points = [];

      // Generate range(70, 130) the domain based on sliders values
      // var prices = Array.from(new Array(0), (x,i) => i + 20);
      var prices = [...Array(20).keys()];
      // prices = [0 to 20 integers]
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        buys.forEach(function (buy, _index, _array) {
          agg_supply += calcDemand(buy, price);
        });
        // console.log('graphBids() plotting x:', price, 'y:', agg_supply);
        points.push({
          x: price,
          y: agg_supply,
        });
      });
    } else {
      // if treatment is cda, sort the buy orders,
      buys.sort((a, b) => (a['p_max'] < b['p_max'] ? 1 : -1));
      var volume = 0.0;
      var points = [];

      buys.forEach(function (buy, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: buy['p_max'],
          y: volume,
        });
        console.error('buy q copy', buy['q_max_cda_copy'], buy['q_max'])
        if (buy['q_max_cda_copy'] !== undefined) {
          volume += buy['q_max_cda_copy'];
        } else {
          volume += buy['q_max'];
        }
        points.push({
          x: buy['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to 0 to show limit order
      points.push({
        x: 0.0,
        y: volume,
      });
    }

    chart.data.datasets[0].data = points;
    chart.update();
  }

  function graphAsks(chart, sells) {
    sells = sells.filter((sell) => sell['status'] == 'active');
    if ('{{treatment}}' != 'cda') {
      if (sells.length == 0) {
        chart.data.datasets[1].data = [];
        chart.update();
        return;
      }

      var points = [];
      var prices = [...Array(20).keys()];
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        sells.forEach(function (sell, _index, _array) {
          agg_supply += calcSupply(sell, price);
        });
        // console.log('graphSells() plotting x:', price, 'y:', agg_supply);
        points.push({
          x: price,
          y: agg_supply,
        });
      });
      // console.log('graphSells() points', points);
    } else {
      sells.sort((a, b) => (a['p_max'] > b['p_max'] ? 1 : -1));
      var volume = 0.0;
      var points = [];
      sells.forEach(function (sell, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: sell['p_max'],
          y: volume,
        });
        console.error('sell q copy', sell['q_max_cda_copy'], sell['q_max'])
        if (sell['q_max_cda_copy'] !== undefined) {
          volume += sell['q_max_cda_copy'];
        } else {
          volume += sell['q_max'];
        }
        points.push({
          x: sell['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to max price = 130 to show limit order
      points.push({
        x: 20.0,
        y: volume,
      });
    }

    chart.data.datasets[1].data = points;
    chart.update();
  }

  // adds to the player's profit
  function updateProfit(chart, profit) {
    //chart.data.datasets[0].data[0] = profit;
    let dataset = chart.series[0];
    const profitFormatted = parseFloat(profit.toFixed(2));
    dataset.addPoint(profitFormatted);
    //chart.update(); // why not update? does it work differently in highcharts or something?
  }

  // Adds or subtracts volume to trader
  function updateVolume(chart, volume) {
    //chart.data.datasets[0].data[0] = volume;
    let dataset = chart.series[0];
    const volumeFormated = parseFloat(volume.toFixed(2));
    dataset.addPoint(volumeFormated);
    //chart.update();
  }

  class BetsUI {
    static #currentBet = null;

    static moveExpiredBet(bet) {
      const id = bet.bet_id;
      this.#removeFromActive(id);
      this.#appendToExpired();
    }

    static getUpcomingBetData() {
      const table = document.querySelector('#activeBets');

      if (table.children.length === 0) return null

      const upcomingBet = table.firstElementChild
      console.log("got bet", upcomingBet)

      const data = {
        quantity: parseFloat(upcomingBet.querySelector(".betQuantity").textContent),
        price: parseFloat(upcomingBet.querySelector(".betPrice").textContent),
        direction: upcomingBet.querySelector(".betDirection").textContent.trim(),
      }

      console.log("got data", data)
      return data
    }

    static #removeFromActive(id) {
      this.#currentBet = document.querySelector(`#a${id}`).cloneNode(true);
      document.querySelector(`#a${id}`).remove();

      ProfitGraph.updateProfitLineFromUpcomingBet()
    }

    static #appendToExpired() {
      const table = document.querySelector('#executedBetsTable');
      table.appendChild(this.#currentBet);
    }

    static convertDeadlinesToSeconds() {
      const rows = [...document.getElementsByClassName('betDeadline')];
      rows.forEach((row) => {
        const ms = math.unit(row.textContent);
        const s = ms.to('s').toString();
        row.textContent = s;
      });
    }

    static decrementDeadlines() {
      const rows = [...document.getElementsByClassName('betDeadline')];
      const zeroSeconds = math.unit('0s');

      rows.forEach((row) => {
        const s = math.unit(row.textContent);
        if (s.equals(zeroSeconds)) return;

        const updatedS = math.subtract(s, math.unit('1s'));
        row.textContent = updatedS.toString();
      });
    }
  }


  function liveRecv(data) {
    // console.timeEnd(`timing`);
    // console.time(`timing`);
    if (data['type'] == 'begin') {
      console.log('Round begin');
    }

    if (data['type'] == 'clear') {
      // to continually move time in the cash and inv graphs, 
      // update cash and inventory bar regardless of changes to cash and inv
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);

      // clear book graph
      klf_line.data.datasets[2].data = [];
      klf_line.update();

      const d = data["payoff_data"]

      const payoff = document.querySelectorAll(".payoff")
      for (let i = 0; i < payoff.length; i++) payoff[i].innerText = d["payoff"]

      const a = document.querySelectorAll(".a")
      for (let i = 0; i < a.length; i++) a[i].innerText = d["endowment"] + d["money_gained_in_market"] - d["money_lost_in_market"]

      const b = document.querySelectorAll(".b")
      for (let i = 0; i < b.length; i++) b[i].innerText = d["money_gained_from_buy_bets"] - d["money_lost_from_sell_bets"]

      const c = document.querySelectorAll(".c")
      for (let i = 0; i < c.length; i++) c[i].innerText = d["c_bar"] * -d["negative_inventory"]

      document.querySelector(".endowment").innerText = d["endowment"]
      document.querySelector(".money_gained_in_market").innerText = d["money_gained_in_market"]
      document.querySelector(".money_lost_in_market").innerText = d["money_lost_in_market"]
      document.querySelector(".money_gained_from_buy_bets").innerText = d["money_gained_from_buy_bets"]
      document.querySelector(".money_lost_from_sell_bets").innerText = d["money_lost_from_sell_bets"]
      document.querySelector(".c_bar").innerText = d["c_bar"]
      document.querySelector(".negative_inventory").innerText = d["negative_inventory"]
    }

    // check if any orders in our orderHistory have expired
    // if so, then get rid of it
    if (data['type'] === 'regraph') {
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
      //   console.warn('should check if order has expired here', data);
      updateOrderHistory(data);
      console.log("order expired here's the data", data)
    }

    if (data['type'] == 'buy' || data['type'] == 'sell') {
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }

    if (data['type'] == 'clearing_price') {
      global_clearing_price = data['clearing_price'];
      if ('{{treatment}}' != 'cda') {
        // console.error('data: ', data);
        graphClearingPrice(
          klf_line,
          data['clearing_price'],
          data['buys'],
          data['sells']
        );
      }
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }

    if (data['type'] == 'bets update') {
      // console.log(tickCount, " bets update", "cash:", data['cash'], "inv:", data['inventory'])
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedDataForOdometer = data;
      BetsUI.moveExpiredBet(data['bet']);
      // updateCashAndInventoryDisplay(data);
    }

    if (data['type'] == 'update') {
      // console.log(tickCount, " update", "cash:", data['cash'], "inv:", data['inventory'])
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedDataForOdometer = data;
      // updateCashAndInventoryDisplay(data);

      const d = data["payoff_data"]
      const payoff = document.querySelectorAll(".payoff")
      for (let i = 0; i < payoff.length; i++) payoff[i].innerText = d["payoff"]

      const a = document.querySelectorAll(".a")
      for (let i = 0; i < a.length; i++) a[i].innerText = d["endowment"] + d["money_gained_in_market"] - d["money_lost_in_market"]

      const b = document.querySelectorAll(".b")
      for (let i = 0; i < b.length; i++) b[i].innerText = d["money_gained_from_buy_bets"] - d["money_lost_from_sell_bets"]

      const c = document.querySelectorAll(".c")
      for (let i = 0; i < c.length; i++) c[i].innerText = d["c_bar"] * -d["negative_inventory"]

      document.querySelector(".endowment").innerText = d["endowment"]
      document.querySelector(".money_gained_in_market").innerText = d["money_gained_in_market"]
      document.querySelector(".money_lost_in_market").innerText = d["money_lost_in_market"]
      document.querySelector(".money_gained_from_buy_bets").innerText = d["money_gained_from_buy_bets"]
      document.querySelector(".money_lost_from_sell_bets").innerText = d["money_lost_from_sell_bets"]
      document.querySelector(".c_bar").innerText = d["c_bar"]
      document.querySelector(".negative_inventory").innerText = d["negative_inventory"]
    }

    tickCount++
  }

  let cachedDataForOdometer;
  function updateCashAndInventoryDisplay(data) {
    if (cachedDataForOdometer === undefined) return;
    cashOdometer.update(parseFloat(data['cash']).toFixed(2));
    invOdometer.update(parseFloat(data['inventory']).toFixed(2));
    // console.error(parseFloat(data['cash']).toFixed(2));
  }

  function new_buy() {
    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
      );
    }

    const volume = parseInt(
      document.getElementById('noUiVolSlider').noUiSlider.get()
    );

    var u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiRateSlider').noUiSlider.get()
      );
    }

    if (minprice > maxprice) {
      alert('Minimum Price should be less than or equal to Maximum Price');
      return;
    }

    const order = {
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      direction: 'buy',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    const valueToBeat = isNewOrderValid(order); // undefined means order is valid
    if (valueToBeat === undefined) {
      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);
    } else {
      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
      }
      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });
    }
  }

  function new_sell() {
    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseFloat(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
      );
    }

    const volume = parseInt(
      document.getElementById('noUiVolSlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiRateSlider').noUiSlider.get()
      );
    }

    const order = {
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      direction: 'sell',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    const valueToBeat = isNewOrderValid(order); // undefined means order is good
    if (valueToBeat === undefined) {
      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);
    } else {
      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the price above ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the minimum price above ${valueToBeat}.`;
      }
      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });
    }
  }

  function new_buy_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'buy_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function new_sell_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'sell_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function appendActiveOrdersTable(order) {
    // console.error('appendActiveOrdersTable: ', order);
    const table = document.querySelector('#activeOrdersTable');
    const newRow = document.createElement('tr');

    const direction = document.createElement('td');
    direction.innerHTML = order.direction === 'buy' ? 'Buy' : 'Sell';

    const price = document.createElement('td');
    price.innerHTML =
      order.p_min === order.p_max
        ? `${order.p_max}`
        : `${order.p_min}-${order.p_max}`;

    const quantity = document.createElement('td');
    quantity.innerHTML = order.q_max;

    if (isFLO) {
      const rate = document.createElement('td');
      rate.innerHTML = order.u_max;

      direction.style.width = '92px';
      price.style.width = '62px';
      quantity.style.width = '90px';
      rate.style.width = '59px';
      newRow.append(direction, price, quantity, rate);
    } else {
      direction.style.width = '91px';
      price.style.width = '61px';
      quantity.style.width = '88px';
      newRow.append(direction, price, quantity);
    }

    // since ids cannot start with number
    newRow.id = 'a' + order.orderID;
    const tableWrapper = document.querySelector('#activeOrdersTableWrapper');

    table.appendChild(newRow);
  }

  if (isCDA || isFBA) {
    hideRateColumnActiveOrdersTable();
  }

  function removeActiveOrderTable(orderID) {
    const rowCopy = document.querySelector(`#a${orderID}`).cloneNode(true);
    document.querySelector(`#a${orderID}`).remove();

    const table = document.querySelector('#executedOrdersTable');
    table.appendChild(rowCopy);
  }

  function hideRateColumnActiveOrdersTable() {
    document.querySelector('#activeOrdersRate').remove();
    document.querySelector('#activeOrdersDirection').style.width = '0';
  }
</script>
<script src="{% static 'flow_market/react.js' %}"></script>
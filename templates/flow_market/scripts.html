{% load otree %}

<!-- Code heavily adopted from Jason Vranek (github.com/JasonVranek) (https://people.ucsc.edu/~jvranek/flow_viz.html) -->

<!-- prettier-ignore -->
{% block constants %} {% include Constants.scripts_constants_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block imports %} {% include Constants.scripts_imports_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block init_graphs %} {% include Constants.scripts_init_graphs_template %}
{% endblock %}
<!-- pretter-ignore -->
{% block init_sliders %} {% include Constants.scripts_init_sliders_template %}
{% endblock %}
<!-- prettier-ignore -->
{% block InputDropdown %} {% include Constants.scripts_InputDropdown_template %}
{% endblock %}

<script>
  console.error("new_sell should be available")

  // DEBUG tick count
  let tickCount = 0
  const ticks = []

  document.addEventListener(
    'DOMContentLoaded',
    () => {
      if ('{{player.id_in_group}}' == 1) {
        liveSend({
          direction: 'begin',
        });
        console.log('begin round');
      }

      Automate.start()

      InputDropdown.hideAlgorithmicInputDropdown();
      BetsUI.convertDeadlinesToSeconds();

      setTimeout(ProfitGraph.updateProfitLineFromUpcomingBet, 1000)

      MarketGraph.updateAxesText()

      ROUND_NUMBER = parseInt(document.querySelector(".roundNum").textContent)
      console.log("HERE")
      console.log("**got roundNum:", ROUND_NUMBER, "query", document.querySelector(".roundNum"), "text", document.querySelector(".roundNum").textContent)

      setInterval(() => {
        // DEBUG tick count
        // ticks.push(tickCount)
        // const avg = ticks.reduce((acc, curr) => acc + curr) / ticks.length
        // console.log("ticks since last second:", tickCount, " avg:", avg.toFixed(2))
        // tickCount = 0

        updateCashAndInventoryDisplay(cachedDataForOdometer);
        BetsUI.decrementDeadlines();
      }, 1000);
    },
    false
  );

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  class DraggableGraphInput {
    // for keeping track if button is either "Send Buy" (true) or "Cancel Buy" (false)
    static isBuyButtonSend = true
    static isSellButtonSend = true

    static blueVal = 0;
    static redVal = 1;

    static topPointVal = 0;
    static yPointVal = 1;
    static middlePointVal = 2;
    static xPointVal = 3;

    static red_bottomPointVal = 0;
    static red_yPointVal = 1;
    static red_middlePointVal = 2;
    static red_topPointVal = 3;

    static blue_cdaTopPointVal = 0;
    static cdaYPointVal = 1;
    static cdaMiddlePoint = 2;
    static cdaTopPointVal = 3;
    static cdaBottomPointVal = 3;
    static cdaMiddlePointVal = 2

    static cdaTopLimit = 19;
    static cdaBottomLimit = 1;
    static cdaXLimit = 0.01;

    static pointMinDifference = 1;

    static floPointStyle = [
      document.querySelector("#blankPointStyle"),
      "circle",
      "rect",
      document.querySelector("#blankPointStyle")
    ];

    static cdaPointStyle = [
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      "rect",
      document.querySelector("#blankPointStyle")
    ];

    static floPointStyleBlank = [
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle")
    ];

    static cdaPointStyleBlank = [
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle"),
      document.querySelector("#blankPointStyle")
    ];

    static floDataAsks = [
      {
        x: 0, // point going to y = 0
        y: 0
      },
      {
        x: 0, // circle
        y: 17
      },
      {
        x: 0, // square
        y: 19
      },
      {
        x: 0, // point going to y = 20, same x as middle point
        y: 20
      }
    ];

    static floDataBids = [
      {
        x: 0, // point going to y = 20
        y: 20
      },
      {
        x: 0, // circle
        y: 3
      },
      {
        x: 0, // square
        y: 1
      },
      {
        x: 0, // point going to y = 0, same x as middle point
        y: 0
      }
    ];

    // for when middlePoint is x = 0, to allow for dragging of middlePoint instead of yPoint, since yPoint's z index is larger than middlePoint
    static CDA_DRAG_BUG_FIX = 1;

    static cdaDataAsks = [
      {
        x: 0, // bottom point
        y: 0
      },
      {
        x: 0, // x point, x always 0, y always same as middle point (initial has .1 to fix drag bug)
        y: 17 - this.CDA_DRAG_BUG_FIX
      },
      {
        x: 0, // mid point
        y: 17
      },
      // todo add point here then change cda points
      {
        x: 0, // top point
        y: 20
      },
    ];

    static cdaDataBids = [
      // todo add point here then change cda points
      {
        x: 0, // top point
        y: 20
      },
      {
        x: 0, // x point, x always 0, y always same as middle point
        y: 3 + this.CDA_DRAG_BUG_FIX
      },
      {
        x: 0, // middle point
        y: 3
      },
      {
        x: 0, // bottom point
        y: 0
      }
    ];

    // used for reverting to intial data
    static floDataAsksCopy = JSON.parse(JSON.stringify(this.floDataAsks))
    static floDataBidsCopy = JSON.parse(JSON.stringify(this.floDataBids))

    static cdaDataAsksCopy = JSON.parse(JSON.stringify(this.cdaDataAsks))
    static cdaDataBidsCopy = JSON.parse(JSON.stringify(this.cdaDataBids))

    static removeBlueHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyleBlank : DraggableGraphInput.cdaPointStyleBlank
      DraggableGraphInput.myLineChart.update();
    }

    static putBackBlueHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle
      DraggableGraphInput.myLineChart.update();
    }

    static removeRedHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyleBlank : DraggableGraphInput.cdaPointStyleBlank
      DraggableGraphInput.myLineChart.update();
    }

    static putBackRedHandles() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["pointStyle"] = isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle
      DraggableGraphInput.myLineChart.update();
    }

    static makeRedTransparent() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["borderColor"] = RED_TRANSPARENT;
      // shouldn't change handle color
      // DraggableGraphInput.myLineChart.data.datasets[this.redVal]["backgroundColor"] = RED_TRANSPARENT;
      DraggableGraphInput.myLineChart.update();
    }

    static shouldDisableRedDrag = false
    static shouldDisableBlueDrag = false

    static showBlueActive() {
      DraggableGraphInput.makeBlueOpaque()
      DraggableGraphInput.disableBlueDrag()
      DraggableGraphInput.removeBlueHandles()
    }

    static showBlueInactive() {
      console.log("blue should be inactive")
      DraggableGraphInput.goToInitialPositionBlue()
      DraggableGraphInput.makeBlueTransparent()
      DraggableGraphInput.enableBlueDrag()
      DraggableGraphInput.putBackBlueHandles()
      DraggableGraphInput.myLineChart.update()
    }

    static showRedActive() {
      DraggableGraphInput.makeRedOpaque()
      DraggableGraphInput.disableRedDrag()
      DraggableGraphInput.removeRedHandles()
    }

    static showRedInactive() {
      DraggableGraphInput.goToInitialPositionRed()
      DraggableGraphInput.makeRedTransparent()
      DraggableGraphInput.enableRedDrag()
      DraggableGraphInput.putBackRedHandles()
      DraggableGraphInput.myLineChart.update()
    }

    static disableRedDrag() {
      DraggableGraphInput.shouldDisableRedDrag = true
    }

    static enableRedDrag() {
      DraggableGraphInput.shouldDisableRedDrag = false
    }

    static disableBlueDrag() {
      DraggableGraphInput.shouldDisableBlueDrag = true
    }

    static enableBlueDrag() {
      DraggableGraphInput.shouldDisableBlueDrag = false
    }

    static makeRedOpaque() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["borderColor"] = RED;
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["backgroundColor"] = RED;
      DraggableGraphInput.myLineChart.update();
    }

    static makeBlueOpaque() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["borderColor"] = BLUE;
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["backgroundColor"] = BLUE;
      DraggableGraphInput.myLineChart.update();
    }

    static makeBlueTransparent() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["borderColor"] = BLUE_TRANSPARENT;
      // don't change handle color
      // DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["backgroundColor"] = BLUE_TRANSPARENT;
      DraggableGraphInput.myLineChart.update();
    }

    static expirationTimeInput = document.querySelector("#expirationTimeInput")
    static getDraggableGraphBidData() {
      // console.log(myLineChart.data.datasets[blueVal]["data"]);
      let minPrice
      let maxPrice
      let volume
      let uMax
      let expirationTimeInput

      if (isFLO) {
        maxPrice = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.yPointVal]["y"];
        minPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.middlePointVal]["y"];
        uMax = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.middlePointVal]["x"];
        // volume = 50
        volume = parseInt(DraggableGraphInput.buyVolInput.value, 10)
        console.log("**got vol:", typeof volume)

        // console.log("buy:", DraggableGraphInput.buyVolInput.value)
        // console.log("sell:", DraggableGraphInput.sellVolInput.value)

        console.log(minPrice, maxPrice, uMax);

      } else if (isCDA) {
        maxPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePoint]["y"];
        volume = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePointVal]["x"];
        minPrice = maxPrice
        uMax = parseInt('{{max_u_max}}');
        console.log("send order", maxPrice, volume);
      }

      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)
      console.log("**time0:", this.expirationTimeInput)
      console.log("**time0:", expirationTimeInput)

      return { minPrice, maxPrice, volume, uMax, expirationTimeInput }
    }

    static getDraggableGraphAlgoBidData() {
      // console.log(myLineChart.data.datasets[blueVal]["data"]);
      let minPrice // y-axis
      let maxPrice // same as minPrice
      let unitsAtATime // x-axis
      let uMax // set by default setting
      let totalVolume // input value
      let expirationTimeInput

      // p_min: minPrice,
      // p_max: maxPrice,
      // q_max: unitsAtATime, // units at a time, should be determined by x-axis
      // q_total: tempTotalVolume, // should be determined by input field

      maxPrice =
        DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePoint]["y"];
      unitsAtATime = DraggableGraphInput.myLineChart.data.datasets[this.blueVal].data[this.cdaMiddlePointVal]["x"];
      minPrice = maxPrice
      uMax = parseInt('{{max_u_max}}');
      totalVolume = parseInt(DraggableGraphInput.buyVolInput.value, 10)
      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)

      console.log("**time1:", expirationTimeInput)

      return {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume,
        expirationTimeInput
      }
    }

    static getDraggableGraphAskData() {
      console.log("got** ask data")
      let minPrice
      let maxPrice
      let volume
      let uMax
      let expirationTimeInput

      // console.log(myLineChart.data.datasets[redVal]["data"]);
      if (isFLO) {
        minPrice = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.yPointVal]["y"];
        maxPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["y"];
        uMax = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["x"];
        // volume = 50;
        volume = parseInt(DraggableGraphInput.sellVolInput.value, 10)
        console.log(minPrice, maxPrice, uMax);
      } else if (isCDA) {
        maxPrice =
          DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.cdaMiddlePoint]["y"];
        volume = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["x"];
        minPrice = maxPrice
        uMax = parseInt('{{max_u_max}}');
        console.log(maxPrice, volume);
      }

      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)

      return { minPrice, maxPrice, volume, uMax, expirationTimeInput }
    }

    static getDraggableGraphAlgoAskData() {
      let minPrice // y-axis
      let maxPrice // same as minPrice
      let unitsAtATime // x-axis
      let uMax // set by default setting
      let totalVolume // input value
      let expirationTimeInput

      // p_min: minPrice,
      // p_max: maxPrice,
      // q_max: unitsAtATime, // units at a time, should be determined by x-axis
      // q_total: tempTotalVolume, // should be determined by input field

      maxPrice =
        DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.cdaMiddlePoint]["y"];
      unitsAtATime = DraggableGraphInput.myLineChart.data.datasets[this.redVal].data[this.middlePointVal]["x"];
      minPrice = maxPrice
      uMax = parseInt('{{max_u_max}}');
      totalVolume = parseInt(DraggableGraphInput.sellVolInput.value, 10)
      expirationTimeInput = parseInt(this.expirationTimeInput.value, 10)

      return {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume
      }
    }

    static config = {
      responsive: true,
      maintainAspectRatio: false,

      plugins: {
        tooltip: { enabled: false },
        dragData: {
          round: 0,
          dragX: true,
          showTooltip: true,

          // controls the ability to start dragging
          onDragStart: function (e, datasetIndex, index, value) {
            const isBlue = datasetIndex === DraggableGraphInput.blueVal;
            const isRed = datasetIndex === DraggableGraphInput.redVal;

            if (isBlue && DraggableGraphInput.shouldDisableBlueDrag) {
              return false
            }

            if (isRed && DraggableGraphInput.shouldDisableRedDrag) {
              return false
            }

            if (isFLO) {
              // disable ability to start dragging for x point and top point
              if (isBlue) {
                // DraggableGraphInput.makeBlueOpaque();
                // DraggableGraphInput.makeRedTransparent();

                const isYPoint = index === DraggableGraphInput.yPointVal;
                const isMiddlePoint = index === DraggableGraphInput.middlePointVal;
                const isXPoint = index === DraggableGraphInput.xPointVal;
                const isTopPoint = index === DraggableGraphInput.topPointVal;

                if (isXPoint || isTopPoint) {
                  return false;
                }
              } else if (isRed) {
                // DraggableGraphInput.makeRedOpaque();
                // DraggableGraphInput.makeBlueTransparent();

                const isYPoint = index === DraggableGraphInput.red_yPointVal;
                const isBottomPoint = index === DraggableGraphInput.red_bottomPointVal;
                const isTopPoint = index === DraggableGraphInput.red_topPointVal;

                if (isBottomPoint || isTopPoint) {
                  return false;
                }
              }
            } else if (isCDA) {
              // disable ability to start dragging for x point and top point
              if (isBlue) {
                // DraggableGraphInput.makeBlueOpaque();
                // DraggableGraphInput.makeRedTransparent();
                console.log("index", index, DraggableGraphInput.cdaMiddlePointVal)
                if (index !== DraggableGraphInput.cdaMiddlePointVal) return false

                // const isYPoint = index === DraggableGraphInput.cdaYPointVal;
                // const isTopPoint = index === DraggableGraphInput.blue_cdaTopPointVal;
                // console.log("drag start", index, "yPoint", isYPoint, "topPoint", isTopPoint)

                // if (isYPoint) {
                //   return false;
                // }

                // if (isTopPoint) {
                //   return false;
                // }
              } else if (isRed) {
                console.log("index", index, DraggableGraphInput.cdaMiddlePointVal)
                if (index !== DraggableGraphInput.cdaMiddlePointVal) return false
                // DraggableGraphInput.makeRedOpaque();
                // DraggableGraphInput.makeBlueTransparent();

                // const isYPoint = index === DraggableGraphInput.cdaYPointVal;
                // const isTopPoint = index === DraggableGraphInput.cdaTopPointVal;
                // if (index === 0 || index == 2 || index === 3) return false // todo check
                // if (isYPoint) {
                //   return false;
                // }

                // if (isTopPoint) {
                //   return false;
                // }
              }
            }
          },

          onDrag: function (e, datasetIndex, index, value) {
            const isBlue = datasetIndex === DraggableGraphInput.blueVal;
            const isRed = datasetIndex === DraggableGraphInput.redVal;

            const bottomYLimit = 1;
            const topYLimit = 19;

            e.target.style.cursor = "grabbing";

            if (isFLO) {
              if (isBlue) {
                const isYPoint = index === DraggableGraphInput.yPointVal;
                const isMiddlePoint = index === DraggableGraphInput.middlePointVal;
                const isXPoint = index === DraggableGraphInput.xPointVal;

                // update xPoint when middlePoint is dragged
                if (isMiddlePoint) {
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.xPointVal]["x"] =
                    value["x"];

                  // prevent yPoint going below limit
                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.middlePointVal][
                      "y"
                    ] = bottomYLimit;
                  }
                }

                // cont here
                if (isYPoint) {
                  console.log("**isYPoint")
                  // prevent yPoint going above top y limit
                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal][
                      "y"
                    ] = bottomYLimit;
                  }
                  if (value["y"] >= topYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal][
                      "y"
                    ] = topYLimit;
                  }

                  const middlePointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.middlePointVal]["y"];

                  // prevent yPoint going below middle
                  if (value["y"] <= middlePointYVal) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"] =
                      middlePointYVal + DraggableGraphInput.pointMinDifference;
                  }

                  // prevent blue yPoint going above red yPoint
                  const redYPoint = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"]
                  if (value["y"] >= redYPoint) {
                    console.log("**here", redYPoint)
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"] = redYPoint - DraggableGraphInput.pointMinDifference
                  }

                  // prevent yPoint moving on x-axis
                  if (value["x"] > 0) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["x"] = 0;
                  }
                }

                // blue, prevent middlePoint going above yPoint
                if (isMiddlePoint) {
                  const yPointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"];
                  if (value["y"] >= yPointYVal) {
                    value["y"] = yPointYVal - DraggableGraphInput.pointMinDifference;
                  }
                }
              } else if (isRed) {
                const isYPoint = index === DraggableGraphInput.red_yPointVal;
                const isMiddlePoint = index === DraggableGraphInput.red_middlePointVal;
                const isTopPoint = index === DraggableGraphInput.red_topPointVal;

                if (isMiddlePoint) {
                  // update topPoint when middlePoint is dragged
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_topPointVal]["x"] =
                    value["x"];

                  // prevent middlePoint going above top y limit
                  if (value["y"] >= topYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_middlePointVal][
                      "y"
                    ] = topYLimit;
                  }

                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_middlePointVal][
                      "y"
                    ] = bottomYLimit;
                  }
                }

                if (isYPoint) {
                  const middlePointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_middlePointVal]["y"];

                  // prevent yPoint going above limit
                  if (value["y"] >= topYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal][
                      "y"
                    ] = topYLimit;
                  }

                  if (value["y"] <= bottomYLimit) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal][
                      "y"
                    ] = bottomYLimit;
                  }

                  // prevent red yPoint going above blue yPoint
                  // cont: test this
                  const blueYPoint = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.yPointVal]["y"]
                  if (value["y"] <= blueYPoint) {
                    console.log("**here", blueYPoint)
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"] = blueYPoint + DraggableGraphInput.pointMinDifference
                  }

                  // prevent yPoint going above middle
                  if (value["y"] >= middlePointYVal) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"] =
                      middlePointYVal - DraggableGraphInput.pointMinDifference;
                  }

                  // prevent yPoint moving on x-axis
                  if (value["x"] > 0) {
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["x"] = 0;
                  }
                }

                // prevent middlePoint going below middle
                if (isMiddlePoint) {
                  const yPointYVal =
                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.red_yPointVal]["y"];

                  if (value["y"] <= yPointYVal) {
                    value["y"] = yPointYVal + DraggableGraphInput.pointMinDifference;
                  }

                  if (value["y"] <= bottomYLimit) {
                    value["y"] = bottomYLimit;
                  }
                }
              }
            } else if (isCDA) {
              if (isBlue) {
                const isMiddlePoint = index === DraggableGraphInput.cdaMiddlePoint;
                // make bottomPoint
                if (isMiddlePoint) {
                  // prevent crossing
                  if (value["y"] >= DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"]) {
                    console.log("corssing")
                    value["y"] = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"] - DraggableGraphInput.pointMinDifference
                  }

                  // don't let go above top limit
                  if (value["y"] >= DraggableGraphInput.cdaTopLimit) {
                    value["y"] = DraggableGraphInput.cdaTopLimit;
                  }

                  // don't let go below bottom limit
                  if (value["y"] <= DraggableGraphInput.cdaBottomLimit) {
                    value["y"] = DraggableGraphInput.cdaBottomLimit;
                  }

                  // set y point to same y value as middle point
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                    value["y"];

                  // not sure what cdaXLimit is for...
                  if (value["x"] <= DraggableGraphInput.cdaXLimit) {
                    value["x"] = DraggableGraphInput.cdaXLimit;

                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                      value["y"] + DraggableGraphInput.CDA_DRAG_BUG_FIX;
                  }

                  // set the x point to the same x value as middle point
                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaBottomPointVal]["x"] =
                    value["x"];

                }
              } else if (isRed) {
                const isMiddlePoint = index === DraggableGraphInput.cdaMiddlePoint;
                // make bottomPoint
                if (isMiddlePoint) {
                  // prevent crossing
                  if (value["y"] <= DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"]) {
                    console.log("corssing 2")
                    value["y"] = DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal].data[DraggableGraphInput.cdaMiddlePointVal]["y"] + DraggableGraphInput.pointMinDifference
                  }

                  if (value["y"] >= DraggableGraphInput.cdaTopLimit) {
                    value["y"] = DraggableGraphInput.cdaTopLimit;
                  }

                  if (value["y"] <= DraggableGraphInput.cdaBottomLimit) {
                    value["y"] = DraggableGraphInput.cdaBottomLimit;
                  }

                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                    value["y"];

                  if (value["x"] <= DraggableGraphInput.cdaXLimit) {
                    value["x"] = DraggableGraphInput.cdaXLimit;

                    DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaYPointVal]["y"] =
                      value["y"] - DraggableGraphInput.CDA_DRAG_BUG_FIX;
                  }

                  DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.redVal].data[DraggableGraphInput.cdaTopPointVal]["x"] =
                    value["x"];
                }
              }
            }

          },

          onDragEnd: function (e, datasetIndex, index, value) {
            e.target.style.cursor = "default";
          }
        }
      },

      onHover: (e, chartElement) => {
        // change cursor if hovering over a point
        if (chartElement[0] != null) {
          if (isFLO) {
            // don't change hover for blue x-axis point and top point
            const isBluePoint = chartElement[0].datasetIndex === DraggableGraphInput.blueVal;
            const isXPoint = chartElement[0].index === DraggableGraphInput.xPointVal;
            const isTopPoint = chartElement[0].index === DraggableGraphInput.topPointVal;

            const isRedPoint = chartElement[0].datasetIndex === DraggableGraphInput.redVal;
            const isRedBottomPoint = chartElement[0].index === DraggableGraphInput.red_bottomPointVal;
            const isRedTopPoint = chartElement[0].index === DraggableGraphInput.red_topPointVal;

            if (isRedPoint && DraggableGraphInput.shouldDisableRedDrag) {
              return
            }
            if (isBluePoint && DraggableGraphInput.shouldDisableBlueDrag) {
              return
            }

            if (isBluePoint && !isXPoint && !isTopPoint) {
              document.querySelector("#draggableGraphInput").style.cursor = "grab";
            }

            if (isRedPoint && !isRedBottomPoint && !isRedTopPoint) {
              document.querySelector("#draggableGraphInput").style.cursor = "grab";
            }
          } else if (isCDA) {
            const isBluePoint = chartElement[0].datasetIndex === DraggableGraphInput.blueVal;
            const isRedPoint = chartElement[0].datasetIndex === DraggableGraphInput.redVal;
            const isMiddlePoint = chartElement[0].index === DraggableGraphInput.cdaMiddlePoint;

            if (isRedPoint && DraggableGraphInput.shouldDisableRedDrag) {
              return
            }
            if (isBluePoint && DraggableGraphInput.shouldDisableBlueDrag) {
              return
            }

            if (isMiddlePoint) {
              document.querySelector("#draggableGraphInput").style.cursor = "grab";
            }
          }
        } else {
          document.querySelector("#draggableGraphInput").style.cursor = "default";
        }
      },

      hover: {
        intersect: true
      },

      scales: {
        y: {
          title: {
            display: true,
            text: isCDA || isFBA ? "Price" : "Price"
          },
          beginAtZero: true,

          suggestedMin: 0, // TODO maybe remove after dan's video
          suggestedMax: 20
        },

        x: {
          title: {
            display: true,
            text: isCDA || isFBA ? "Volume" : "Rate"
          },
          beginAtZero: true,

          suggestedMin: 1, // TODO maybe remove after dan's video
          suggestedMax: isCDA || isFBA ? 100 : 5
        }
      }
    };

    static myLineChart = new Chart(document.querySelector("#draggableGraphInput"), {
      type: "scatter",
      data: {
        datasets: [
          {
            borderWidth: 2,
            pointStyle: "line",

            label: "Bids",
            borderColor: BLUE_TRANSPARENT,
            backgroundColor: BLUE,
            fill: false,
            showLine: true,

            pointStyle: isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle,

            pointRadius: 6,
            lineTension: 0,
            pointHitRadius: 25,
            data: isFLO ? DraggableGraphInput.floDataBids : DraggableGraphInput.cdaDataBids
          },
          {
            borderWidth: 2,
            pointStyle: "line",

            label: "Asks",
            borderColor: RED_TRANSPARENT,
            backgroundColor: RED,
            fill: false,
            showLine: true,
            lineTension: 0,

            pointStyle: isFLO ? DraggableGraphInput.floPointStyle : DraggableGraphInput.cdaPointStyle,

            pointRadius: 6,
            lineTension: 0,
            pointHitRadius: 25,
            data: isFLO ? DraggableGraphInput.floDataAsks : DraggableGraphInput.cdaDataAsks
          }
        ]
      },

      options: DraggableGraphInput.config
    });

    static goToInitialPositionRed() {
      DraggableGraphInput.myLineChart.data.datasets[this.redVal]["data"] = isFLO ? JSON.parse(JSON.stringify(DraggableGraphInput.floDataAsksCopy)) : JSON.parse(JSON.stringify(DraggableGraphInput.cdaDataAsksCopy))
      DraggableGraphInput.myLineChart.update();
    }

    static goToInitialPositionBlue() {
      DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["data"] = isFLO ? JSON.parse(JSON.stringify(DraggableGraphInput.floDataBidsCopy)) : JSON.parse(JSON.stringify(DraggableGraphInput.cdaDataBidsCopy))
      console.log("***data:", DraggableGraphInput.myLineChart.data.datasets[this.blueVal]["data"])
      DraggableGraphInput.myLineChart.update()
    }

    static sendNewBuyFromDraggableGraph() {
      let { minPrice, maxPrice, volume, uMax, expirationTimeInput } = DraggableGraphInput.getDraggableGraphBidData()

      // expirationTimeInput = 99
      console.log("**time:", expirationTimeInput)
      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: volume,
        u_max: isFLO ? uMax : parseInt('{{max_u_max}}'),
        direction: 'buy',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentBuyOrder = order

      const valueToBeat = isNewOrderValid(order); // undefined means order is valid

      if (valueToBeat === undefined) {
        orderHistory.push(order);
        appendActiveOrdersTable(order);
        liveSend(order);
      } else {
        let errorText;
        if (isCDA || isFBA) {
          // cda/fba: can only buy when buy's p_max < sell's p_max
          // cda/fba: can only sell when sell's p_max > buy's p_max
          errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
        } else if (isFLO) {
          // flo: can only sell when p_min is > buy's p_max
          // flo: can only buy when p_max < sell's p_min
          errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
        }

        Swal.fire({
          title: 'Cannot Trade With Yourself',
          icon: 'warning',
          text: errorText,
          showClass: {
            popup: 'animate__animated animate__fadeIn',
          },
        });
      }
    }

    // TODO: copy from new_algo_buy
    static sendNewAlgoBuyFromDraggableGraph() {
      let {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume,
        expirationTimeInput
      } = this.getDraggableGraphAlgoBidData();

      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: unitsAtATime, // units at a time, should be determined by x-axis
        u_max: uMax,
        direction: 'algo_buy',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),

        q_total: totalVolume, // should be determined by input field
        executed_units: 0,
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentBuyOrder = order

      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);

      console.log("**sent algo buy order: ", order)
    }

    static handleCancelBuyButtonClick() {
      let order = JSON.parse(JSON.stringify(this.recentBuyOrder))
      order.direction = 'cancel'

      liveSend(order);
    }

    static handleCancelSellButtonClick() {
      let order = JSON.parse(JSON.stringify(this.recentSellOrder))
      order.direction = 'cancel'

      liveSend(order);
    }

    static algoToggle = false;

    static handleBuyButtonClick() {
      if (!this.isBuyButtonSend) {
        this.turnBuyButtonSend()
        this.handleCancelBuyButtonClick()
        // this.sendBuyOrderCancellation()
      } else {
        // turn button to "Cancel Sell"
        this.turnBuyButtonCancel()
        this.isBuyButtonSend = false

        if (this.algoToggle) {
          this.sendNewAlgoBuyFromDraggableGraph()
        } else {
          this.sendNewBuyFromDraggableGraph()
        }
      }
    }

    static handleSellButtonClick() {
      if (!this.isSellButtonSend) {
        this.turnSellButtonSend()
        this.handleCancelSellButtonClick()
        // this.sendSellOrderCancellation()
      } else {
        // turn button to "Cancel Sell"
        this.turnSellButtonCancel()
        this.isSellButtonSend = false

        if (this.algoToggle) {
          this.sendNewAlgoSellFromDraggableGraph()
        } else {
          this.sendNewSellFromDraggableGraph()
        }
      }
    }

    static recentSellOrder = null
    static recentBuyOrder = null

    static sendNewSellFromDraggableGraph() {
      let { minPrice, maxPrice, volume, uMax, expirationTimeInput } = DraggableGraphInput.getDraggableGraphAskData()

      if (minPrice > maxPrice) {
        console.error("minPrice > maxPrice")
        return
      }

      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: volume,
        u_max: uMax,
        direction: 'sell',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentSellOrder = order
      console.log("**sendSell order:", order)

      const valueToBeat = isNewOrderValid(order); // undefined means order is good
      if (valueToBeat === undefined) {
        console.log("**sendSell order1:", order)
        orderHistory.push(order);
        appendActiveOrdersTable(order);
        liveSend(order);
      } else {
        let errorText;
        if (isCDA || isFBA) {
          // cda/fba: can only buy when buy's p_max < sell's p_max
          // cda/fba: can only sell when sell's p_max > buy's p_max
          errorText = `Your sell order will cross with one of your buy orders. Try increasing the price above ${valueToBeat}.`;
        } else if (isFLO) {
          // flo: can only sell when p_min is > buy's p_max
          // flo: can only buy when p_max < sell's p_min
          errorText = `Your sell order will cross with one of your buy orders. Try increasing the minimum price above ${valueToBeat}.`;
        }

        Swal.fire({
          title: 'Cannot Trade With Yourself',
          icon: 'warning',
          text: errorText,
          showClass: {
            popup: 'animate__animated animate__fadeIn',
          },
        });
      }
    }

    static sendNewAlgoSellFromDraggableGraph() {
      let {
        minPrice,
        maxPrice,
        unitsAtATime,
        uMax,
        totalVolume,
        expirationTimeInput
      } = this.getDraggableGraphAlgoAskData();

      const order = {
        p_min: minPrice,
        p_max: maxPrice,
        q_max: unitsAtATime, // units at a time, should be determined by x-axis
        u_max: uMax,
        direction: 'algo_sell',
        status: 'active',
        timestamp: performance.now(),
        orderID: uuidv4(),

        q_total: totalVolume, // should be determined by input field
        executed_units: 0,
        expiration_time: expirationTimeInput // in SECONDS
      };

      this.recentBuyOrder = order

      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);

      console.log("sent algo buy order: ", order)
    }

    static buyButton = document.querySelector("#sendBidDraggableGraphInput")
    static sellButton = document.querySelector("#sendAskDraggableGraphInput")

    static buyVolInput = document.querySelector("#buyVolumeInput")
    static sellVolInput = document.querySelector("#sellVolumeInput")

    //static widgets =  document.querySelectorAll(".notChecked")

    static buyWidget = document.querySelector("#buyWidget")
    static sellWidget = document.querySelector("#sellWidget")

    static turnBuyButtonCancel() {
      this.buyButton.innerText = "Cancel Buy"
      this.buyButton.classList.remove('btn-primary');
      this.buyButton.classList.add('btn-outline-primary');

      this.showBlueActive()
    }

    static turnBuyButtonSend() {
      this.buyButton.innerText = "Send Buy"
      this.buyButton.classList.add('btn-primary');
      this.buyButton.classList.remove('btn-outline-primary');

      this.showBlueInactive()
      this.isBuyButtonSend = true
    }

    static turnSellButtonCancel() {
      this.sellButton.innerText = "Cancel Sell"
      this.sellButton.classList.remove('btn-danger');
      this.sellButton.classList.add('btn-outline-danger');

      this.showRedActive()
    }

    static turnSellButtonSend() {
      this.sellButton.innerText = "Send Sell"
      this.sellButton.classList.add('btn-danger');
      this.sellButton.classList.remove('btn-outline-danger');

      this.showRedInactive()
      this.isSellButtonSend = true
    }

    static handleAlgorithmicOrderToggle(e) {
      this.algoToggle = e.target.checked

      // Change x-axis and show the widgets
      if (this.algoToggle) {
        this.config.scales.x.title.text = "Units at a Time"
        this.buyWidget.classList.remove("notChecked");
        this.sellWidget.classList.remove("notChecked");
        this.buyWidget.classList.add("checked");
        this.sellWidget.classList.add("checked");
      } else {
        // no widgets
        this.config.scales.x.title.text = "Volume"
        this.buyWidget.classList.add("notChecked");
        this.sellWidget.classList.add("notChecked");
        this.buyWidget.classList.remove("checked");
        this.sellWidget.classList.remove("checked");
      }

      this.myLineChart.options = this.config
      this.myLineChart.update()
    }
  }

  let testVar = 0

  function test() {
    // new_algo_buy()
    new_algo_sell()
    // console.log("buy:", DraggableGraphInput.buyVolInput.value)
    // console.log("buy:", DraggableGraphInput.buyVolInput)
    // console.log("sell:", DraggableGraphInput.sellVolInput.value)
    // console.log("initial**")
    // console.log("***data click:", DraggableGraphInput.myLineChart.data.datasets[DraggableGraphInput.blueVal]["data"])
    // testVar++
    // DraggableGraphInput.showBlueInactive()
    // DraggableGraphInput.showRedInactive()
    // if (testVar % 2 === 0) {
    //   DraggableGraphInput.turnSellButtonCancel()
    // } else {
    //   DraggableGraphInput.turnSellButtonSend()
    // }
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


  class Automate {
    static playerID = parseInt("{{player.id_in_group}}")
    static #AUTOMATE_ENABLED = false

    static delay(ms) { return new Promise(res => setTimeout(res, ms)) }

    static start() {
      if (!this.#AUTOMATE_ENABLED) return

      if (isFLO) {
        switch (this.playerID) {
          case 1:
            this.#player1ActionsFLO()
            break;
          case 2:
            this.#player2ActionsFLO()
            break;
          case 3:
            this.#player3ActionsFLO()
            break;
          default:
            console.error("switch case error")
        }
      } else if (isCDA) {
        switch (this.playerID) {
          case 1:
            this.#player1ActionsCDA()
            break;
          case 2:
            this.#player2ActionsCDA()
            break;
          case 3:
            this.#player3ActionsCDA()
            break;
          default:
            console.error("switch case error")
        }
      }
    }

    static #player1ActionsFLO() {
      setTimeout(() =>
        new_buy(true, 1, 10, 20, 5),
        1 * 1000
      )
      setTimeout(() =>
        new_buy(true, 1, 10, 20, 5),
        5 * 1000
      )

    }

    static #player2ActionsFLO() {
      setTimeout(() =>
        new_sell(true, 1, 10, 100, 5),
        10 * 1000
      )
    }

    static #player3ActionsFLO() {
    }


    //////////////////////////
    static #player1ActionsCDA() {
      setTimeout(() =>
        new_buy(true, null, 5, 20, 1),
        2 * 1000
      )
      setTimeout(() =>
        new_buy(true, null, 13, 20, 1),
        2 * 1000
      )

    }

    static #player2ActionsCDA() {
      setTimeout(() =>
        new_sell(true, null, 1, 20, 1),
        10 * 1000
      )
    }

    static #player3ActionsCDA() {
      // setTimeout(() =>
      //   new_buy(true, null, 9, 20, 1),
      //   5 * 1000
      // )
    }


    //////////////////////////////////


    static setSliders(minPrice, maxPrice, volume, uMax) {
      if (isCDA || isFBA) {
        document.getElementById('noUiPriceSlider').noUiSlider.set(maxPrice)
      } else if (isFLO) {
        document.getElementById('noUiPriceSlider').noUiSlider.set([minPrice, maxPrice])
      }

      document.getElementById('noUiVolSlider').noUiSlider.set(volume)

      if (isFLO) {
        document.getElementById('noUiRateSlider').noUiSlider.set(uMax)
      }
    }
  }

  let orderHistory = [];

  // update order history if an order has expired
  function updateOrderHistory(data) {
    console.log("**cancel", data, orderHistory)
    orderHistory = orderHistory.filter((order) => {
      console.log("**cancel do i come here?", order)
      let arrayToSearch;
      if (order.direction === 'buy' || order.direction === 'algo_buy') arrayToSearch = data.buys;
      if (order.direction === 'sell' || order.direction === 'algo_sell') arrayToSearch = data.sells;
      if (arrayToSearch === undefined) console.error('updateOrderHistory()');

      console.log("**cancel arrayToSearch", arrayToSearch)

      const orderInData = arrayToSearch.find((orderInData) => {
        return orderInData.orderID === order.orderID;
      });

      console.log("**cancel got id:", orderInData)

      // BUG orderInData is sometimes undefined, not sure if due to liveserver delay with orderHistory
      if (orderInData === undefined) {
        console.error('orderInData undefined', order);
      }

      if (orderInData === undefined || orderInData.status === 'expired') {
        console.log("**algoCancel: got order:", orderInData)

        // turn "Cancel Buy" button into "Send Buy"
        if (order.direction === 'buy' || order.direction === 'algo_buy')
          DraggableGraphInput.turnBuyButtonSend();
        if (order.direction === 'sell' || order.direction === 'algo_sell')
          DraggableGraphInput.turnSellButtonSend();

        // remove from active orders table
        removeActiveOrderTable(order.orderID);

        // update profit graph
        ProfitGraph.addOrderData(orderInData)

        return false;
      } else {
        return true;
      }
    });
  }

  // check if potential order does not conflict with any orders in orderHistory
  function isNewOrderValid(newOrder) {
    if (orderHistory.length === 0) return undefined;

    // cda/fba: can only buy when buy's p_max < sell's p_max
    // cda/fba: can only sell when sell's p_max > buy's p_max
    let numToBeValid;
    if (isCDA || isFBA) {
      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_max < minPrice ? order.p_max : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }

      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_max > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }
    }

    // flo: can only sell when p_min is > buy's p_max
    // flo: can only buy when p_max < sell's p_min
    if (isFLO) {
      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_min > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }

      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_min < minPrice ? order.p_min : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }
    }

    return numToBeValid;
  }

  ///////////////////////////////////////////////////////////////////////////////////

  var ctx = document.getElementById('myChart').getContext('2d');
  // profitGraph
  var myChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
      datasets: [
        {
          borderWidth: 0,
          pointStyle: 'line',

          label: "",
          data: [],
          fill: { above: RED, below: GREEN, target: { value: 10 } },
          pointRadius: 0,
          borderColor: "",
        },
        {
          borderWidth: 2,
          pointStyle: 'line',

          label: 'Profit Line',
          data: [],
          fill: false,
          pointRadius: 0,
          borderColor: 'black',
        },

        {
          borderWidth: 2,
          pointStyle: 'rect',

          label: 'Profit',
          borderColor: GREEN,
          backgroundColor: GREEN,
          // backgroundColor: 'rgba(0, 0, 0, 0)',
          fill: false,
          showLine: true,
          lineTension: 0,
          data: [],
        },

        {
          borderWidth: 2,
          pointStyle: 'rect',

          label: 'Loss',
          borderColor: RED,
          backgroundColor: RED,
          // backgroundColor: 'rgba(0, 0, 0, 0)',
          fill: false,
          showLine: true,
          lineTension: 0,
          data: [],
        },
      ]
    },
    options: {
      maintainAspectRatio: false,
      plugins: {
        legend: {
          labels: {
            usePointStyle: true,
          }
        }
      },
      scales: {
        y: {
          suggestedMin: 50,
          suggestedMax: 100,

          title: {
            display: true,
            text: 'Price',
          },
          beginAtZero: true,
        },

        x: {
          ticks: {
            stepSize: 2,
            autoSkip: false,
            callback: function (value, index, values) {
              if (this.chart.data.labels.length - 1 % 2 === 0) {
                if (value % 5 === 1) {
                  // console.log("**bet is odd ", this)
                  return value;
                }
              } else {
                if (value % 5 === 0) {
                  // console.log("**bet is even ", this)
                  return value;
                }
              }

              return null
            },
          },

          title: {
            display: true,
            text: 'Quantity                   ',
          },
          beginAtZero: true,
        },
      }
    }
  });

  class ProfitGraph {
    static chart = myChart
    static profitLineValue = 0
    static totalExecutedVol = 0 // TODO
    static betDirection = ""

    static potentialProfit = 0
    static cashAfterBet = 0
    static invAfterBet = 0

    static updateProfitLineFromUpcomingBet() {
      const betData = BetsUI.getUpcomingBetData()
      if (betData !== null) {
        const { quantity, price, direction } = betData

        this.profitLineValue = price
        this.betDirection = direction
        this.potentialProfit = 0

        ProfitGraph.setLabelsBasedOnBet(myChart, quantity, price, direction)
      }
    }

    static addOrderData(order) {
      // TODO add conditional for if order and bet are compatible to graph
      // if (order["direction"].includes("buy"))
      console.log("addorderinfo", order)
      const { executedProfit, executedVolume } = order
      const pricePerVol = Math.abs(executedProfit) / Math.abs(executedVolume)

      console.log("*testProfit executedProfit: ", executedProfit, "vol", executedVolume, "price per vol", pricePerVol)
      // if (BetsUI.#currentBet == null) {
      //   console.error("current bet is null when trying to calculate profit, what?")
      //   return
      // }

      // console.log("*curr bet", BetsUI.#currentBet)



      this.updatePotentialProfit(executedProfit, executedVolume, pricePerVol, order)
      this.updateInvAfterBet()

      console.log("* pricePerVol", pricePerVol)

      for (let i = 0; i <= Math.abs(executedVolume).toFixed(0.001); i++) {
        this.chart.data.datasets[0].data.push(pricePerVol)
        console.log("*testProfit pushed", pricePerVol, "i:", i)
      }

      this.chart.update();
    }

    static updateCashAfterBet() {
      const betData = BetsUI.getUpcomingBetData()
      if (betData == null) return

      const { quantity: betVolume, price: betPrice, direction: betDirection } = betData

      if (betDirection.includes("BUY")) {
        console.log()

        this.cashAfterBet = cash + (betVolume * betPrice)
        console.log("* this.cashAfterBet1", this.cashAfterBet, "cash: ", cash, "adding", (betVolume * betPrice))

        this.invAfterBet = inventory - betVolume

      } else if (betDirection.includes("SELL")) {

        this.cashAfterBet = cash - (betVolume * betPrice)
        console.log("* this.cashAfterBet", this.cashAfterBet)
        this.invAfterBet = inventory + betVolume

      }

      document.querySelector(".cashAfterBet").textContent = `cash after bet: ${Math.round(this.cashAfterBet)}`
      console.log("* this.cashAfterBet", this.cashAfterBet)
      document.querySelector(".invAfterBet").textContent = `inventory after bet: ${Math.round(this.invAfterBet)}`
    }

    static updateInvAfterBet() {

    }

    static updatePotentialProfit(executedProfit, executedVolume, executedPricePerVol, order) {
      console.log("*profit updatePotentialProfit")
      const betData = BetsUI.getUpcomingBetData()
      if (betData == null) return

      const { quantity: betVolume, price: betPrice, direction: betDirection } = betData

      // quantity: 50, price: 9, direction: "BUY"}
      let potentialProfitChange

      if (betDirection.includes("BUY")) {
        console.log("*profit 1 updatePotentialProfit")
        potentialProfitChange = Math.abs(Math.min(betVolume, executedVolume)) * (betPrice - executedPricePerVol)
      } else if (betDirection.includes("SELL")) {
        console.log("*profit 2 updatePotentialProfit")
        potentialProfitChange = Math.abs(Math.min(betVolume, executedVolume)) * (executedPricePerVol - betPrice)
      }

      console.log("*profit 3 updatePotentialProfit, got", potentialProfitChange)
      console.log("*profit all variables", betVolume, betPrice, betDirection, executedProfit, executedVolume, executedPricePerVol)
      console.log("*profit order", order)

      this.potentialProfit += potentialProfitChange

      console.log("potentialProfit:", this.potentialProfit)
      document.querySelector(".potentialProfit").textContent = `area (additional cash you will make from the bet, not including what you will recieve from the bet): ${Math.round(this.potentialProfit)}`
    }

    static setLabelsBasedOnBet(chart, betQuantity, betPrice, betDirection) {
      // x-axis values (labels)
      const newLabels = []
      for (let i = 0; i <= betQuantity; i++) {
        newLabels.push(i)
      }
      chart.data.labels = newLabels

      const profitPriceLine = []
      for (let i = 0; i <= betQuantity; i++) {
        profitPriceLine.push(betPrice)
      }
      chart.data.datasets[1].data = profitPriceLine

      // set profit price line
      chart.data.datasets[0].fill.target.value = betPrice
      chart.options.scales.y.suggestedMax = betPrice

      if (betDirection.includes("BUY")) {
        console.log("below green for buy")
        chart.data.datasets[0].fill.above = RED
        chart.data.datasets[0].fill.below = GREEN
      } else if (betDirection.includes("SELL")) {
        console.log("below red for sell")
        chart.data.datasets[0].fill.above = GREEN
        chart.data.datasets[0].fill.below = RED
      } else {
        console.error("betDirection not recognized")
      }

      chart.update();
    }

    static removeData(chart) {
      chart.data.labels.pop();
      chart.data.datasets.forEach((dataset) => {
        dataset.data.pop();
      });
      chart.update();
    }
  }

  function debug() {
    test()
    // console.log("test")
    // MarketGraph.flipGraphAxes()
  }

  class MarketGraph {
    static flipAxes = true

    static flipGraphAxes() {
      MarketGraph.flipAxes = !MarketGraph.flipAxes
      MarketGraph.regraphAllGraphs()
      MarketGraph.updateAxesText()
    }

    static regraphAllGraphs() {
      graphClearingPrice(klf_line, null, null, null, true)
      // functon graphClearingPrice(chart, price = null, buys = null, sells = null, regraph = false) {

      graphBids(klf_line, null, true)
      // functon graphBids(chart, buys = null, regraph = false) {

      graphAsks(klf_line, null, true)
      // functon graphAsks(chart, sells = null, regraph = false) {
    }

    static updateAxesText() {
      if (isCDA || isFBA) {
        if (MarketGraph.flipAxes) {
          klf_line.options.scales.x.title.text = "Volume            "
          klf_line.options.scales.y.title.text = "Price"
        } else {
          klf_line.options.scales.x.title.text = "Price            "
          klf_line.options.scales.y.title.text = "Volume"
        }
      } else if (isFLO) {
        console.log("**flipping")
        if (MarketGraph.flipAxes) {
          console.log("** 1flipping")
          klf_line.options.scales.x.title.text = "Rate             "
          klf_line.options.scales.y.title.text = "Price"
        } else {
          console.log("** 2flipping")
          klf_line.options.scales.x.title.text = "Price                "
          klf_line.options.scales.y.title.text = "Rate"
        }
      }

      klf_line.update()
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////

  const graphs = init_graphs();
  const klf_line = graphs[2];
  const cash_bar = graphs[0];
  const inventory_bar = graphs[1];

  const slider = createNoUiPriceSlider();
  const noUiVolSlider = createNoUiVolSlider();
  const noUiRateSlider = createNoUiRateSlider();

  const noUiAlgoTimeSlider = createNoUiAlgoTimeSlider();
  const noUiAlgoQuantitySlider = createNoUiAlgoQuantitySlider();
  const noUiAlgoPriceSlider = createNoUiAlgoPriceSlider();
  const noUiAlgoVolSlider = createnoUiAlgoVolSlider();
  const noUiAlgoRateSlider = createNoUiAlgoRateSlider();

  const [cashOdometer, invOdometer, earningsOdometer] = intializeOdometers();

  if ('{{treatment}}' != 'flo') {
    // Because cda and fba has a fixed u_max
    document.querySelector('.noUiRateSliderWrapper').remove();
    document.querySelector('.noUiAlgoRateSliderWrapper').remove();
  }

  function calcDemand(buy, price) {
    if (price <= buy.p_min) {
      if (buy.q_max < buy.u_max) {
        // Don't trade more than q_max
        return buy.q_max;
      }
      // Trade at max rate if p <= p_min
      return buy.u_max;
    } else if (price > buy.p_max) {
      // Don't trade if price is higher than max willingness to buy
      return 0.0;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
      if (trade_vol > buy.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return buy.q_max;
      }
      return trade_vol;
    }
  }

  function calcSupply(sell, price) {
    if (price < sell.p_min) {
      // Don't trade if price is lower than min willingness to sell
      return 0.0;
    } else if (price >= sell.p_max) {
      if (sell.q_max < sell.u_max) {
        // Don't trade more than q_max
        return sell.q_max;
      }
      // Trade at max rate if p >= p_max
      return sell.u_max;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        sell.u_max +
        ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
      if (trade_vol > sell.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return sell.q_max;
      }
      return trade_vol;
    }
  }

  let lastDataToGraphClearingPrice = {
    price: undefined,
    buys: undefined,
    sells: undefined
  }

  function graphClearingPrice(chart, price = null, buys = null, sells = null, regraph = false) {

    if (regraph === true && price === null && sells === null && buys === null) {
      if (chart.data.datasets[2].data.length === 0) return
      let { price, buys, sells } = lastDataToGraphClearingPrice
    } else {
      lastDataToGraphClearingPrice = { price, buys, sells }
    }

    console.log("cached graph clearing price:", lastDataToGraphClearingPrice)


    buys = buys.filter((buy) => buy['status'] == 'active');
    sells = sells.filter((sell) => sell['status'] == 'active');

    var agg_supply = 0.0; // agg_supply will be equal to agg_demand
    sells.forEach(function (sell, _index, _array) {
      agg_supply += calcSupply(sell, price);
    });

    var points = [];

    if (MarketGraph.flipAxes) {
      points.push({ x: 0.0, y: price });
      points.push({ x: agg_supply, y: price });
      points.push({ x: agg_supply, y: 0.0 });
    } else {
      points.push({ x: 0.0, y: agg_supply });
      points.push({ x: price, y: agg_supply });
      points.push({ x: price, y: 0.0 });
    }

    chart.data.datasets[2].data = points;
    chart.update();
  }

  let lastDataToGraphBids
  function graphBids(chart, buys = null, regraph = false) {
    console.log("graphBids() buys:")
    console.log(buys)
    console.log("")

    if (regraph === true && buys === null) {
      if (chart.data.datasets[0].data.length === 0) return
      buys = lastDataToGraphBids
    } else {
      lastDataToGraphBids = buys
    }

    buys = buys.filter((buy) => buy['status'] == 'active');

    if ('{{treatment}}' != 'cda') {

      // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply
      if (buys.length == 0) {
        chart.data.datasets[0].data = [];
        chart.update();
        return;
      }

      var points = [];

      // Generate range(70, 130) the domain based on sliders values
      // var prices = Array.from(new Array(0), (x,i) => i + 20);
      var prices = [...Array(20).keys()];
      // prices = [0 to 20 integers]
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        buys.forEach(function (buy, _index, _array) {
          agg_supply += calcDemand(buy, price);
        });

        // console.log('graphBids() plotting x:', price, 'y:', agg_supply);
        points.push({
          x: price,
          y: agg_supply,
        });

      });
    } else {
      // if treatment is cda, sort the buy orders,
      buys.sort((a, b) => (a['p_max'] < b['p_max'] ? 1 : -1));

      var volume = 0.0;
      var points = [];

      buys.forEach(function (buy, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: buy['p_max'],
          y: volume,
        });

        if (buy['q_max_cda_copy'] !== undefined) {
          volume += buy['q_max_cda_copy'];
        } else {
          volume += buy['q_max'];
        }

        points.push({
          x: buy['p_max'],
          y: volume,
        });

      });

      // insert a horizontal line to 0 to show limit order
      points.push({
        x: 0.0,
        y: volume,
      });
    }

    if (MarketGraph.flipAxes) {
      for (let i = 0; i < points.length; i++) {
        var new_x = points[i].y;
        var new_y = points[i].x;
        points[i].y = new_y;
        points[i].x = new_x;
      }
    }

    chart.data.datasets[0].data = points;
    chart.update();
  }

  let lastDataToGraphAsks
  function graphAsks(chart, sells = null, regraph = false) {
    console.log("graphBids() sells:")
    console.log(sells)
    console.log("")

    if (regraph === true && sells === null) {
      if (chart.data.datasets[1].data.length === 0) {
        return
      }
      sells = lastDataToGraphAsks
    } else {
      lastDataToGraphAsks = sells
    }

    sells = sells.filter((sell) => sell['status'] == 'active');

    if ('{{treatment}}' != 'cda') {

      if (sells.length == 0) {
        chart.data.datasets[1].data = [];
        chart.update();
        return;
      }

      var points = [];
      var prices = [...Array(20).keys()];

      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;

        sells.forEach(function (sell, _index, _array) {
          agg_supply += calcSupply(sell, price);
        });

        points.push({
          x: price,
          y: agg_supply,
        });
      });

      if (MarketGraph.flipAxes) {
        for (let i = 0; i < points.length; i++) {
          var new_x = points[i].y;
          var new_y = points[i].x;
          points[i].y = new_y;
          points[i].x = new_x;
        }
      }

    } else {
      // Sort the asks in increasing order (lowest price first)
      sells.sort((a, b) => (a['p_max'] > b['p_max'] ? 1 : -1));

      var volume = 0.0;
      var points = [];

      sells.forEach(function (sell, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: sell['p_max'],
          y: volume,
        });

        if (sell['q_max_cda_copy'] !== undefined) {
          volume += sell['q_max_cda_copy'];
        } else {
          volume += sell['q_max'];
        }

        points.push({
          x: sell['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to max price = 130 to show limit order
      points.push({
        x: 20.0,
        y: volume,
      });

      if (MarketGraph.flipAxes) {
        for (let i = 0; i < points.length; i++) {
          var new_x = points[i].y;
          var new_y = points[i].x;
          points[i].y = new_y;
          points[i].x = new_x;
        }
      }
    }

    chart.data.datasets[1].data = points;
    chart.update();
  }

  // adds to the player's profit
  function updateProfit(chart, profit) {
    //chart.data.datasets[0].data[0] = profit;
    let dataset = chart.series[0];
    const profitFormatted = parseFloat(profit.toFixed(2));
    dataset.addPoint(profitFormatted);
    //chart.update(); // why not update? does it work differently in highcharts or something?
  }

  // Adds or subtracts volume to trader
  function updateVolume(chart, volume) {
    //chart.data.datasets[0].data[0] = volume;
    let dataset = chart.series[0];
    const volumeFormated = parseFloat(volume.toFixed(2));
    dataset.addPoint(volumeFormated);
    //chart.update();
  }

  class BetsUI {
    static #recentBet = null;
    // static recentBetPrice = null
    // static recentBetVol = null

    static moveExpiredBet(bet) {
      const id = bet.bet_id;
      this.#removeFromActive(id);
      this.#appendToExpired();

      ProfitGraph.updateProfitLineFromUpcomingBet()
    }

    static getUpcomingBetData() {
      const table = document.querySelector('#activeBets');

      if (table.children.length === 0) return null

      const upcomingBet = table.firstElementChild
      console.log("got bet", upcomingBet)

      const data = {
        quantity: parseFloat(upcomingBet.querySelector(".betQuantity").textContent),
        price: parseFloat(upcomingBet.querySelector(".betPrice").textContent),
        direction: upcomingBet.querySelector(".betDirection").textContent.trim(),
      }

      console.log("got data", data)
      return data
    }

    static #removeFromActive(id) {
      this.#recentBet = document.querySelector(`#a${id}`).cloneNode(true);
      document.querySelector(`#a${id}`).remove();
    }

    static #appendToExpired() {
      const table = document.querySelector('#executedBetsTable');
      table.appendChild(this.#recentBet);
    }

    static convertDeadlinesToSeconds() {
      const rows = [...document.getElementsByClassName('betDeadline')];
      rows.forEach((row) => {
        const ms = math.unit(row.textContent);
        const s = ms.to('s').toString();
        row.textContent = s;
      });
    }

    static decrementDeadlines() {
      const rows = [...document.getElementsByClassName('betDeadline')];
      const zeroSeconds = math.unit('0s');

      rows.forEach((row) => {
        const s = math.unit(row.textContent);
        if (s.equals(zeroSeconds)) return;

        const updatedS = math.subtract(s, math.unit('1s'));
        row.textContent = updatedS.toString();
      });
    }
  }

  function liveRecv(data) {
    // This was a hack for preventing previous update()'s from affecting the current round
    // A better solution would be to just find a way to get a reference to the interval in the backend and delete it before moving on to the next round
    // if (ROUND_NUMBER !== data['round']) {
    //   // console.log("wrong round")
    //   console.log("data", data)
    //   return;
    // }


    // console.timeEnd(`timing`);
    // console.time(`timing`);
    if (isFLO) {
      // what appears if it's flo
      document.querySelector("#isFLO").style.display = "initial"
      document.querySelector("#isCDA").style.display = "none"
      document.querySelector("#CDAOnly").style.visibility = "hidden"
      document.querySelector("#buyWidget").classList.remove("notChecked");
      document.querySelector("#sellWidget").classList.remove("notChecked");
      document.querySelector("#buyWidget").classList.add("checked");
      document.querySelector("#sellWidget").classList.add("checked");
    }

    if (isCDA) {
      // what appears if it's cda
      document.querySelector("#isCDA").style.display = "initial"
      document.querySelector("#isFLO").style.display = "none"
      document.querySelector("#CDAOnly").style.visibility = "visible"
    }


    if (data['type'] == 'begin') {
      console.log('Round begin');
    }

    if (data['type'] == 'clear') {
      // to continually move time in the cash and inv graphs, 
      // update cash and inventory bar regardless of changes to cash and inv

      // commenting this two line out fixed the up and down bug??
      // updateProfit(cash_bar, data['cash']);
      // updateVolume(inventory_bar, data['inventory']);

      // clear book graph
      klf_line.data.datasets[2].data = [];
      klf_line.update();

      // lastDataToGraphClearingPrice

      const d = data["payoff_data"]

      const payoff = document.querySelectorAll(".payoff")
      for (let i = 0; i < payoff.length; i++) payoff[i].innerText = d["payoff"]

      const a = document.querySelectorAll(".a")
      for (let i = 0; i < a.length; i++) a[i].innerText = d["endowment"] + d["money_gained_in_market"] - d["money_lost_in_market"]

      const b = document.querySelectorAll(".b")
      for (let i = 0; i < b.length; i++) b[i].innerText = d["money_gained_from_buy_bets"] - d["money_lost_from_sell_bets"]

      const c = document.querySelectorAll(".c")
      for (let i = 0; i < c.length; i++) c[i].innerText = d["c_bar"] * -d["negative_inventory"]

      document.querySelector(".endowment").innerText = d["endowment"]
      document.querySelector(".money_gained_in_market").innerText = d["money_gained_in_market"]
      document.querySelector(".money_lost_in_market").innerText = d["money_lost_in_market"]
      document.querySelector(".money_gained_from_buy_bets").innerText = d["money_gained_from_buy_bets"]
      document.querySelector(".money_lost_from_sell_bets").innerText = d["money_lost_from_sell_bets"]
      document.querySelector(".c_bar").innerText = d["c_bar"]
      document.querySelector(".negative_inventory").innerText = d["negative_inventory"]
    }

    // check if any orders in our orderHistory have expired
    // if so, then get rid of it
    if (data['type'] === 'regraph') {
      console.log("*regraph")
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
      //   console.warn('should check if order has expired here', data);
      updateOrderHistory(data);
      console.log("order expired here's the data", data)
    }

    if (data['type'] == 'buy' || data['type'] == 'sell') {
      // where does this come from?

      console.log("*incoming data:")
      console.log(data)

      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }

    if (data['type'] == 'clearing_price') {
      console.log("*graph got clearing price")
      global_clearing_price = data['clearing_price'];
      if ('{{treatment}}' != 'cda') {
        // console.error('data: ', data);
        graphClearingPrice(
          klf_line,
          data['clearing_price'],
          data['buys'],
          data['sells']
        );
      }
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }

    if (data['type'] == 'bets update') {
      // console.log(tickCount, " bets update", "cash:", data['cash'], "inv:", data['inventory'])
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedDataForOdometer = data;
      cash = data['cash']
      inventory = data['inventory']
      const d = data["payoff_data"]
      earnings = d["payoff"] - d["endowment"] + (20 * Math.min(0, data['inventory']))
      document.querySelector("#earningsInfo").innerText = earnings
      BetsUI.moveExpiredBet(data['bet']);
      // updateCashAndInventoryDisplay(data);
    }

    if (data['type'] == 'update') {
      console.log("*graph update")
      // console.log(tickCount, " update", "cash:", data['cash'], "inv:", data['inventory'])
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      cachedDataForOdometer = data;
      cash = data['cash']
      inventory = data['inventory']

      const d = data["payoff_data"]
      earnings = d["payoff"] - d["endowment"] + (20 * Math.min(0, data['inventory']))
      document.querySelector("#earningsInfo").innerText = earnings
      // updateCashAndInventoryDisplay(data);

      const payoff = document.querySelectorAll(".payoff")
      for (let i = 0; i < payoff.length; i++) payoff[i].innerText = d["payoff"]

      const a = document.querySelectorAll(".a")
      for (let i = 0; i < a.length; i++) a[i].innerText = d["endowment"] + d["money_gained_in_market"] - d["money_lost_in_market"]

      const b = document.querySelectorAll(".b")
      for (let i = 0; i < b.length; i++) b[i].innerText = d["money_gained_from_buy_bets"] - d["money_lost_from_sell_bets"]

      const c = document.querySelectorAll(".c")
      for (let i = 0; i < c.length; i++) c[i].innerText = d["c_bar"] * -d["negative_inventory"]

      document.querySelector(".endowment").innerText = d["endowment"]
      document.querySelector(".money_gained_in_market").innerText = d["money_gained_in_market"]
      document.querySelector(".money_lost_in_market").innerText = d["money_lost_in_market"]
      document.querySelector(".money_gained_from_buy_bets").innerText = d["money_gained_from_buy_bets"]
      document.querySelector(".money_lost_from_sell_bets").innerText = d["money_lost_from_sell_bets"]
      document.querySelector(".c_bar").innerText = d["c_bar"]
      document.querySelector(".negative_inventory").innerText = d["negative_inventory"]
    }

    tickCount++
  }

  let cachedDataForOdometer;
  let cash = 0
  let inventory = 0
  function updateCashAndInventoryDisplay(data) {
    if (cachedDataForOdometer === undefined) return;

    cashOdometer.update(parseFloat(cash).toFixed(2));
    invOdometer.update(parseFloat(inventory).toFixed(2));

    ProfitGraph.updateCashAfterBet()

    // console.error(parseFloat(data['cash']).toFixed(2));
  }

  function new_algo_buy(isAutomated = false, tempMinPrice = null, tempMaxPrice = null, tempVolume = null, tempUMax = null, tempTotalVolume = null) {
    console.log("new algo_buy")
    let maxPrice;
    let minPrice;
    let uMax
    let volume

    if (isAutomated) {
      if (isCDA && tempMinPrice !== null && tempMinPrice !== tempMaxPrice) {
        console.error("CDA prices are supposed to be the same")
      }

      maxPrice = tempMaxPrice
      minPrice = isFLO ? tempMinPrice : tempMaxPrice


      volume = tempVolume

      if (isCDA || isFBA) {
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = tempUMax
      }

      console.log("*** using uMax", uMax)

      Automate.setSliders(minPrice, maxPrice, volume, uMax)

    } else {
      if (isCDA || isFBA) {
        maxPrice = parseInt(
          document.getElementById('noUiPriceSlider').noUiSlider.get()
        );
        minPrice = maxPrice;

      } else if (isFLO) {
        maxPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
        );
        minPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
        );
      }

      volume = parseInt(
        document.getElementById('noUiVolSlider').noUiSlider.get()
      );

      if ('{{treatment}}' != 'flo') {
        // use rate slider if flo
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = parseInt(document.getElementById('noUiRateSlider').noUiSlider.get());
      }
    }

    if (minPrice > maxPrice) {
      console.error("minPrice > maxPrice")
      return
    }

    const order = {
      // p_min: minPrice,
      // p_max: maxPrice,
      // q_max: volume,
      // u_max: uMax,
      ///////////////////////
      // p_min: 10,
      p_min: minPrice,
      // p_max: 10,
      p_max: maxPrice,
      u_max: uMax,
      direction: 'algo_buy',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),

      q_max: volume, // this is units at a time
      // q_total: 50, // TODO: need to make new function parameter
      q_total: tempTotalVolume,
      executed_units: 10,
      expiration_time: 40 // in SECONDS
    };

    orderHistory.push(order);
    appendActiveOrdersTable(order);
    liveSend(order);

    console.log("**sending algo_buy:", order)

    // const valueToBeat = isNewOrderValid(order); // undefined means order is valid

    // if (valueToBeat === undefined) {

    //   orderHistory.push(order);
    //   appendActiveOrdersTable(order);
    //   liveSend(order);

    // } else {

    //   let errorText;
    //   if (isCDA || isFBA) {
    //     // cda/fba: can only buy when buy's p_max < sell's p_max
    //     // cda/fba: can only sell when sell's p_max > buy's p_max
    //     errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
    //   } else if (isFLO) {
    //     // flo: can only sell when p_min is > buy's p_max
    //     // flo: can only buy when p_max < sell's p_min
    //     errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
    //   }

    //   Swal.fire({
    //     title: 'Cannot Trade With Yourself',
    //     icon: 'warning',
    //     text: errorText,
    //     showClass: {
    //       popup: 'animate__animated animate__fadeIn',
    //     },
    //   });

    // }
  }

  function new_algo_sell(isAutomated = false, tempMinPrice = null, tempMaxPrice = null, tempVolume = null, tempUMax = null) {
    console.log("new algo_sell")
    let maxPrice;
    let minPrice;
    let uMax
    let volume

    if (isAutomated) {
      if (isCDA && tempMinPrice !== null && tempMinPrice !== tempMaxPrice) {
        console.error("CDA prices are supposed to be the same")
      }

      maxPrice = tempMaxPrice
      minPrice = isFLO ? tempMinPrice : tempMaxPrice


      volume = tempVolume

      if (isCDA || isFBA) {
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = tempUMax
      }

      console.log("*** using uMax", uMax)

      Automate.setSliders(minPrice, maxPrice, volume, uMax)

    } else {
      if (isCDA || isFBA) {
        maxPrice = parseInt(
          document.getElementById('noUiPriceSlider').noUiSlider.get()
        );
        minPrice = maxPrice;

      } else if (isFLO) {
        maxPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
        );
        minPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
        );
      }

      volume = parseInt(
        document.getElementById('noUiVolSlider').noUiSlider.get()
      );

      if ('{{treatment}}' != 'flo') {
        // use rate slider if flo
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = parseInt(document.getElementById('noUiRateSlider').noUiSlider.get());
      }
    }

    if (minPrice > maxPrice) {
      console.error("minPrice > maxPrice")
      return
    }

    const order = {
      // p_min: minPrice,
      // p_max: maxPrice,
      // q_max: volume,
      // u_max: uMax,
      p_min: 10,
      p_max: 10,
      u_max: uMax,
      direction: 'algo_sell',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),

      q_max: 6, // this is units at a time
      q_total: 50,
      executed_units: 10,
      // expiration_time: 4 // in SECONDS
      expiration_time: 20 // in SECONDS
    };

    orderHistory.push(order);
    appendActiveOrdersTable(order);
    liveSend(order);

    console.log("**sending algo_sell:", order)

    // const valueToBeat = isNewOrderValid(order); // undefined means order is valid

    // if (valueToBeat === undefined) {

    //   orderHistory.push(order);
    //   appendActiveOrdersTable(order);
    //   liveSend(order);

    // } else {

    //   let errorText;
    //   if (isCDA || isFBA) {
    //     // cda/fba: can only buy when buy's p_max < sell's p_max
    //     // cda/fba: can only sell when sell's p_max > buy's p_max
    //     errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
    //   } else if (isFLO) {
    //     // flo: can only sell when p_min is > buy's p_max
    //     // flo: can only buy when p_max < sell's p_min
    //     errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
    //   }

    //   Swal.fire({
    //     title: 'Cannot Trade With Yourself',
    //     icon: 'warning',
    //     text: errorText,
    //     showClass: {
    //       popup: 'animate__animated animate__fadeIn',
    //     },
    //   });

    // }
  }

  function new_buy(isAutomated = false, tempMinPrice = null, tempMaxPrice = null, tempVolume = null, tempUMax = null) {
    let maxPrice;
    let minPrice;
    let uMax
    let volume

    if (isAutomated) {
      if (isCDA && tempMinPrice !== null && tempMinPrice !== tempMaxPrice) {
        console.error("CDA prices are supposed to be the same")
      }

      maxPrice = tempMaxPrice
      minPrice = isFLO ? tempMinPrice : tempMaxPrice


      volume = tempVolume

      if (isCDA || isFBA) {
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = tempUMax
      }

      console.log("*** using uMax", uMax)

      Automate.setSliders(minPrice, maxPrice, volume, uMax)

    } else {
      if (isCDA || isFBA) {
        maxPrice = parseInt(
          document.getElementById('noUiPriceSlider').noUiSlider.get()
        );
        minPrice = maxPrice;

      } else if (isFLO) {
        maxPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
        );
        minPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
        );
      }

      volume = parseInt(
        document.getElementById('noUiVolSlider').noUiSlider.get()
      );

      if ('{{treatment}}' != 'flo') {
        // use rate slider if flo
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = parseInt(document.getElementById('noUiRateSlider').noUiSlider.get());
      }
    }

    if (minPrice > maxPrice) {
      console.error("minPrice > maxPrice")
      return
    }

    const order = {
      p_min: minPrice,
      p_max: maxPrice,
      q_max: volume,
      u_max: uMax,
      direction: 'buy',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    const valueToBeat = isNewOrderValid(order); // undefined means order is valid

    if (valueToBeat === undefined) {

      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);

    } else {

      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
      }

      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });

    }
  }

  function new_sell(isAutomated = false, tempMinPrice = null, tempMaxPrice = null, tempVolume = null, tempUMax = null) {
    let maxPrice;
    let minPrice;
    let uMax;
    let volume;

    if (isAutomated) {

      if (isCDA && tempMinPrice !== null && tempMinPrice !== tempMaxPrice) {
        console.error("CDA prices are supposed to be the same")
      }

      maxPrice = tempMaxPrice
      minPrice = isFLO ? tempMinPrice : tempMaxPrice

      volume = tempVolume

      if (isCDA || isFBA) {
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = tempUMax
      }
      console.log("*** using uMax sell", uMax)
      Automate.setSliders(minPrice, maxPrice, volume, uMax)

    } else {

      if (isCDA || isFBA) {
        maxPrice = parseInt(
          document.getElementById('noUiPriceSlider').noUiSlider.get()
        );
        minPrice = maxPrice;
      } else if (isFLO) {
        maxPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
        );
        minPrice = parseFloat(
          document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
        );
      }

      volume = parseInt(
        document.getElementById('noUiVolSlider').noUiSlider.get()
      );

      if ('{{treatment}}' != 'flo') {
        // use rate slider if flo
        uMax = parseInt('{{max_u_max}}');
      } else {
        uMax = parseInt(
          document.getElementById('noUiRateSlider').noUiSlider.get()
        );
      }
    }

    if (minPrice > maxPrice) {
      console.error("minPrice > maxPrice")
      return
    }

    const order = {
      p_min: minPrice,
      p_max: maxPrice,
      q_max: volume,
      u_max: uMax,
      direction: 'sell',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    const valueToBeat = isNewOrderValid(order); // undefined means order is good
    if (valueToBeat === undefined) {
      orderHistory.push(order);
      appendActiveOrdersTable(order);
      liveSend(order);
    } else {
      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the price above ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the minimum price above ${valueToBeat}.`;
      }

      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });
    }
  }

  function new_buy_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'buy_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function new_sell_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'sell_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function appendActiveOrdersTable(order) {
    // console.error('appendActiveOrdersTable: ', order);
    const table = document.querySelector('#activeOrdersTable');
    const newRow = document.createElement('tr');

    const direction = document.createElement('td');
    direction.innerHTML = order.direction === 'buy' ? 'Buy' : 'Sell';

    const price = document.createElement('td');
    price.innerHTML =
      order.p_min === order.p_max
        ? `${order.p_max}`
        : `${order.p_min}-${order.p_max}`;

    const quantity = document.createElement('td');
    quantity.innerHTML = order.q_max;

    if (isFLO) {
      const rate = document.createElement('td');
      rate.innerHTML = order.u_max;

      direction.style.width = '92px';
      price.style.width = '62px';
      quantity.style.width = '90px';
      rate.style.width = '59px';
      newRow.append(direction, price, quantity, rate);
    } else {
      direction.style.width = '91px';
      price.style.width = '61px';
      quantity.style.width = '88px';
      newRow.append(direction, price, quantity);
    }

    // since ids cannot start with number
    newRow.id = 'a' + order.orderID;
    const tableWrapper = document.querySelector('#activeOrdersTableWrapper');

    table.appendChild(newRow);
  }

  if (isCDA || isFBA) {
    hideRateColumnActiveOrdersTable();
  }

  function removeActiveOrderTable(orderID) {
    const rowCopy = document.querySelector(`#a${orderID}`).cloneNode(true);
    document.querySelector(`#a${orderID}`).remove();

    const table = document.querySelector('#executedOrdersTable');
    table.appendChild(rowCopy);

    return rowCopy
    updateCashAfterBet
  }

  function hideRateColumnActiveOrdersTable() {
    document.querySelector('#activeOrdersRate').remove();
    document.querySelector('#activeOrdersDirection').style.width = '0';
  }
</script>
<!-- <script src="{% static 'flow_market/react.js' %}"></script> -->
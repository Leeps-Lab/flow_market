{% load otree %}

<!--
            Code heavily adopted from Jason Vranek (github.com/JasonVranek)
        -->
<script type="module" src="{% static 'flow_market/market.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
<script src="https://code.highcharts.com/highcharts.js"></script>
<script>
   document.addEventListener('DOMContentLoaded', function() {
       if({{player.id_in_group}} == 1){
           liveSend({'direction': 'begin'});
           console.log("begin round");
       }
   }, false);

    Chart.defaults.global.defaultFontFamily = 'Nunito';


   function init_graphs() {
       var cash_ctx = document.getElementById('cash-bar');
       var cash_bar = Highcharts.chart('cash-bar', {
           credits: {
    enabled: false
  },
           title: {
               // text: 'Cash'
               text: undefined
           },

           yAxis: {
               title: {
                   // text: 'Cash'
                   text: undefined
               }
           },

           xAxis: {
               title: {
                   text: 'Time'
               }
           },

           legend: {
               layout: 'vertical',
               align: 'right',
               verticalAlign: 'middle'
           },

           plotOptions: {
               series: {
                   label: {
                       connectorAllowed: false
                   },
                   marker: {
                       enabled: false
                   }
               }
           },

           series: [{
               name: 'Cash',
               data: [{{player.cash}}]
           }],

           responsive: {
               rules: [{
                   condition: {
                       maxWidth: 500
                   }
               }]
           }
       });


       var inv_ctx = document.getElementById('inv-bar');
       var inventory_bar = Highcharts.chart('inv-bar', {
           credits: {
    enabled: false
  },
           title: {
               // text: 'Inventory'
               text: undefined
           },

           yAxis: {
               title: {
                   // text: 'Units'
                   text: undefined
               }
           },

           xAxis: {
               title: {
                   text: 'Time'
               }

           },

           legend: {
               layout: 'vertical',
               align: 'right',
               verticalAlign: 'middle'
           },

           plotOptions: {
               series: {
                   label: {
                       connectorAllowed: false
                   },
                   marker: {
                       enabled: false
                   }
               }
           },

           series: [{
               name: 'Inventory',
               data: [{{player.inventory}}]
           }],

           responsive: {
               rules: [{
                   condition: {
                       maxWidth: 500
                   }
               }]
           }
       });

       var klf_line_ctx = document.getElementById('klf-line');
       var klf_line = new Chart(klf_line_ctx, {
           type: 'scatter',
           options: {
               maintainAspectRatio: false,
               scales: {
                   yAxes: [{
                       ticks: {
                           // beginAtZero: true,
                       },
                   }]
               },
               title: {
                   display: true,
                   text: 'Market',
               },
               elements: {
                   point: {
                       radius: 3,
                       pointStyle: 'dash',
                   },
               },
           },
           data: {
               datasets: [{
                   label: 'Bids',
                   borderColor: "#0000fe",
                   backgroundColor: 'rgba(0, 0, 0, 0)',
                   fill: false,
                   showLine: true,
                   lineTension: 0,
                   data: [],
               }, {
                   label: 'Asks',
                   borderColor: "#fb0009",
                   backgroundColor: 'rgba(0, 0, 0, 0)',
                   fill: false,
                   showLine: true,
                   lineTension: 0,
                   data: [],
               }, {
                   label: 'Clearing Price',
                   borderColor: "#55d22e",
                   backgroundColor: 'rgba(0, 0, 0, 0)',
                   fill: false,
                   showLine: true,
                   lineTension: 0,
                   data: [],
               }]
           },
       });

       return [cash_bar, inventory_bar, klf_line];
   }

   let graphs = init_graphs();
   let klf_line = graphs[2];
   let cash_bar = graphs[0];
   let inventory_bar = graphs[1];

   // Initialize the UI elements
   var minpriceSlider = document.getElementById("minpriceSlider");
   var minpriceValue = document.getElementById("minpriceValue");
   var volSlider = document.getElementById("volSlider");
   var volValue = document.getElementById("volValue");
   var rateSlider = document.getElementById("rateSlider");
   var rateValue = document.getElementById("rateValue");
   var maxpriceSlider = document.getElementById("maxpriceSlider");
   var maxpriceValue = document.getElementById("maxpriceValue");

   minpriceSlider.value = 10;
   minpriceValue.innerHTML = "Min Price: " + minpriceSlider.value;

   volSlider.value = 50;
   volValue.innerHTML = "Max Volume: " + volSlider.value;

   rateSlider.value = 3;
   rateValue.innerHTML = "Max Rate: " + rateSlider.value;

   maxpriceSlider.value = 10;
   // From demo: in CDA, max price and min price are the same
   if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
       maxpriceValue.innerHTML = "Price: " + maxpriceSlider.value;
   } else {
       maxpriceValue.innerHTML = "Max Price: " + maxpriceSlider.value;
   }

   minpriceSlider.oninput = function() {
       minpriceValue.innerHTML = "Min Price: " + this.value;
   }

   volSlider.oninput = function() {
       volValue.innerHTML = "Max Volume: " + this.value;
   }

   rateSlider.oninput = function() {
       rateValue.innerHTML = "Max Rate: " + this.value;
   }

   maxpriceSlider.oninput = function() {
       if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
           // From demo: in CDA, max price and min price are the same
           // console.log("minprice slider applied")
           maxpriceValue.innerHTML = "Price: " + this.value;
           minpriceValue.innerHTML = "Should be same as max Price: " + this.value;
           minpriceSlider.value = this.value;
       } else {
           maxpriceValue.innerHTML = "Max Price: " + this.value;
       }
   }

   var algo_minpriceSlider = document.getElementById("algo-minpriceSlider");
   var algo_minpriceValue = document.getElementById("algo-minpriceValue");
   var algo_volSlider = document.getElementById("algo-volSlider");
   var algo_volValue = document.getElementById("algo-volValue");
   var algo_rateSlider = document.getElementById("algo-rateSlider");
   var algo_rateValue = document.getElementById("algo-rateValue");
   var algo_maxpriceSlider = document.getElementById("algo-maxpriceSlider");
   var algo_maxpriceValue = document.getElementById("algo-maxpriceValue");
   var algo_timeSlider = document.getElementById("algo-timeSlider");
   var algo_timeValue = document.getElementById("algo-timeValue");
   var algo_quantitySlider = document.getElementById("algo-quantitySlider");
   var algo_quantityValue = document.getElementById("algo-quantityValue");

   algo_minpriceSlider.value = 10;
   algo_minpriceValue.innerHTML = "Min Price: " + algo_minpriceSlider.value;

   algo_volSlider.value = 50;
   algo_volValue.innerHTML = "Max Volume: " + algo_volSlider.value;

   algo_rateSlider.value = 3;
   algo_rateValue.innerHTML = "Max Rate: " + algo_rateSlider.value;

   algo_maxpriceSlider.value = 10;
   // From demo: in CDA, max price and min price are the same
   if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
       algo_maxpriceValue.innerHTML = "Price: " + algo_maxpriceSlider.value;
   } else {
       algo_maxpriceValue.innerHTML = "Max Price: " + algo_maxpriceSlider.value;
   }

   algo_timeSlider.value = 3;
   algo_timeValue.innerHTML = "Expiration time: " + algo_timeSlider.value;

   algo_quantitySlider.value = 10;
   algo_quantityValue.innerHTML = "Units at a time: " + algo_quantitySlider.value;


   algo_minpriceSlider.oninput = function() {
       algo_minpriceValue.innerHTML = "Min Price: " + this.value;

       // if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
           // // From demo: in CDA, max price and min price are the same
           // console.log("minprice slider applied")
           // algo_minpriceSlider.value = algo_maxpriceValue;
       // }
       // if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
       //     // From demo: in CDA, max price and min price are the same
       //     console.log("minprice slider applied")
       //     algo_minpriceValue.innerHTML = "Min Price: " + algo_maxpriceSlider.value;
       // } else {
       //     algo_minpriceValue.innerHTML = "Min Price: " + this.value;
       // }
   }

   algo_volSlider.oninput = function() {
       algo_volValue.innerHTML = "Max Volume: " + this.value;
       console.log(`min: ${minpriceValue} max: ${maxpriceValue}`)
   }

   algo_rateSlider.oninput = function() {
       algo_rateValue.innerHTML = "Max Rate: " + this.value;
   }

   algo_maxpriceSlider.oninput = function() {
       if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
           // From demo: in CDA, max price and min price are the same
           console.log("minprice slider applied")
           algo_maxpriceValue.innerHTML = "Price: " + this.value;
           algo_minpriceValue.innerHTML = "Should be same as max Price: " + this.value;
           algo_minpriceSlider.value = this.value;
       } else {
           algo_maxpriceValue.innerHTML = "Max Price: " + this.value;
       }
   }

   algo_timeSlider.oninput = function() {
       algo_timeValue.innerHTML = "Expiration time: " + this.value;
   }

   algo_quantitySlider.oninput = function() {
       algo_quantityValue.innerHTML = "Units at a time: " + this.value;
   }

   if ('{{treatment}}' != 'flo') {
       // DONE are rateSlider and rateValue removed if treatment is cda/fba?
       // if treatment is cda/fba, then remove max rate slider
       // if treatment is flo, have a max rate slider
       // this is for both the manual and the algorithmic input

       // Because cda and fba has a fixed u_max
       rateSlider.remove();
       rateValue.remove();
       algo_rateSlider.remove();
       algo_rateValue.remove();


       // From demo: in CDA, max price and min price are the same
       minpriceSlider.style.display = "none"
       minpriceValue.style.display = "none"
       algo_minpriceSlider.style.display = "none"
       algo_minpriceValue.style.display = "none"
       document.querySelectorAll(".minpriceSpacing").forEach((node) => {
           console.log(node)
           node.style.display = "none"
       })
       document.querySelectorAll(".algo-minpriceSpacing").forEach((node) => {
           console.log(node)
           node.style.display = "none"
       })
       // CHANGING
       // maxpriceValue.innerHTML = "Price: " + maxpriceSlider.value;
       // algo_maxpriceValue.innerHTML = "Price: " + algo_maxpriceSlider.value;
       // minpriceSlider.remove()
       // algo_minpriceSlider.remove()
       // algo_minpriceValue.innerHTML = "Min Price: " + algo_minpriceSlider.value;
   }

   function calcDemand(buy, price) {
       if (price <= buy.p_min) {
           if (buy.q_max < buy.u_max) {
               // Don't trade more than q_max
               return buy.q_max;
           }
           // Trade at max rate if p <= p_min
           return buy.u_max;
       } else if (price > buy.p_max) {
           // Don't trade if price is higher than max willingness to buy
           return 0.0;
       } else {
           // The price fell p_min < price < p_max
           let trade_vol = buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
           if (trade_vol > buy.q_max) {
               // Saturate to q_max if trade_vol will exceed q_max
               return buy.q_max;
           }
           return trade_vol;
       }
   }

   function calcSupply(sell, price) {
       if (price < sell.p_min) {
           // Don't trade if price is lower than min willingness to sell
           return 0.0;
       } else if (price >= sell.p_max) {
           if (sell.q_max < sell.u_max) {
               // Don't trade more than q_max
               return sell.q_max;
           }
           // Trade at max rate if p >= p_max
           return sell.u_max;
       } else {
           // The price fell p_min < price < p_max
           let trade_vol = sell.u_max + ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
           if (trade_vol > sell.q_max) {
               // Saturate to q_max if trade_vol will exceed q_max
               return sell.q_max;
           }
           return trade_vol;
       }
   }

   function graphClearingPrice(chart, price, buys, sells) {
       buys = buys.filter(buy => buy['status'] == 'active');
       sells = sells.filter(sell => sell['status'] == 'active');
       var agg_supply = 0.0; // agg_supply will be equal to agg_demand
       sells.forEach(function (sell, _index, _array) {
               agg_supply += calcSupply(sell, price);
       });
       var points = [];

       points.push({x: 0.0, y: agg_supply});
       points.push({x: price, y: agg_supply});
       points.push({x: price, y: 0.0});

       chart.data.datasets[2].data = points;
       chart.update();
   }


   function graphBids(chart, buys) {
       buys = buys.filter(buy => buy['status'] == 'active');
       if('{{treatment}}' != 'cda'){ // TEST changes
           // READ
           // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply
           if (buys.length == 0) {
               chart.data.datasets[0].data = [];
               chart.update();
               return;
           }

           var points = [];

           // Generate range(70, 130) the domain based on sliders values
           // var prices = Array.from(new Array(0), (x,i) => i + 20);
           var prices = [...Array(20).keys()];
           prices.forEach(function (price, _index, _array) {
               var agg_supply = 0.0;
               buys.forEach(function (buy, _index, _array) {
                   agg_supply += calcDemand(buy, price);
               });
               points.push({x: price, y: agg_supply});
           });
       }else{
           // if treatment is cda, sort the buy orders,
           buys.sort((a, b) => (a['p_max'] < b['p_max']) ? 1 : -1);
           var volume = 0.0;
  var points = [];

           buys.forEach(function (buy, _index, _array) {
    // Graph (price, old_vol) -> (price, new_vol)
    points.push({x: buy['p_max'], y: volume});
    volume += buy['q_max'];
    points.push({x: buy['p_max'], y: volume});
  });

  // insert a horizontal line to 0 to show limit order
  points.push({x: 0.0, y: volume})
       }


       chart.data.datasets[0].data = points;
       chart.update();
   }

   function graphAsks(chart, sells) {
       sells = sells.filter(sell => sell['status'] == 'active');
       if('{{treatment}}' != 'cda'){ // TEST changes
           // READ
           if (sells.length == 0) {
               chart.data.datasets[1].data = [];
               chart.update();
               return;
           }

           var points = [];
           var prices = [...Array(20).keys()];
           prices.forEach(function (price, _index, _array) {
               var agg_supply = 0.0;
               sells.forEach(function (sell, _index, _array) {
                   agg_supply += calcSupply(sell, price);
               });
               points.push({x: price, y: agg_supply});
           });
       } else{
           sells.sort((a, b) => (a['p_max'] > b['p_max']) ? 1 : -1);
  var volume = 0.0;
  var points = [];
  sells.forEach(function (sell, _index, _array) {
    // Graph (price, old_vol) -> (price, new_vol)
    points.push({x: sell['p_max'], y: volume});
    volume += sell['q_max'];
    points.push({x: sell['p_max'], y: volume});
  });

  // insert a horizontal line to max price = 130 to show limit order
  points.push({x: 20.0, y: volume})
       }


       chart.data.datasets[1].data = points;
       chart.update();
   }

   // adds to the player's profit
   function updateProfit(chart, profit) {
       //chart.data.datasets[0].data[0] = profit;
       let dataset = chart.series[0];
       dataset.addPoint(profit);
       //chart.update();
   }

   // Adds or subtracts volume to trader
   function updateVolume(chart, volume) {
       //chart.data.datasets[0].data[0] = volume;
       let dataset = chart.series[0];
       dataset.addPoint(volume);
       //chart.update();
   }


   let order_id = 1;

   function liveRecv(data){
       if(data['type'] == 'begin'){
           console.log("Round begin");
       }
       if(data['type'] == 'clear'){
           klf_line.data.datasets[2].data = [];
  klf_line.update();
       }
       if(data['type'] == 'buy' || data['type'] == 'sell' || data['type'] == 'regraph'){
           console.log(data);
           graphBids(klf_line, data['buys']);
  graphAsks(klf_line, data['sells']);
       }
       if(data['type'] == 'clearing_price'){
           console.log(data);
           global_clearing_price = data['clearing_price'];
           // READ
           if('{{treatment}}' != 'cda') graphClearingPrice(klf_line, data['clearing_price'], data['buys'], data['sells']); // TEST changes
           graphBids(klf_line, data['buys']);
  graphAsks(klf_line, data['sells']);
       }
       if(data['type'] == 'update'){
           console.log(data);
           document.getElementById("cashInfo").innerHTML ="Cash " + Number.parseFloat(data['cash']).toFixed(2);
           document.getElementById("invInfo").innerHTML = "Inventory " + Number.parseFloat( data['inventory']).toFixed(2);
           updateProfit(cash_bar, data['cash']);
  updateVolume(inventory_bar, data['inventory']);
       }
   };



   function new_buy(){
       var minprice = parseInt(document.getElementById("minpriceSlider").value);
       var volume = parseInt(document.getElementById("volSlider").value);
       var maxprice = parseInt(document.getElementById("maxpriceSlider").value);
       var u_max;
       if('{{treatment}}' != 'flo'){ // use rate slider if flo
           u_max = parseInt({{max_u_max}});
       } else{
           u_max = parseInt(document.getElementById("rateSlider").value);
       }


       if(minprice > maxprice){
           alert("Minimum Price should be less than or equal to Maximum Price")
           return;
       }

       liveSend({
           'p_min': minprice,
           'p_max': maxprice,
           'q_max': volume,
           'u_max': u_max,
           'direction': 'buy',
           'status': 'active',
           'timestamp':performance.now()
       });
       order_id += 1;
   };

   function new_sell(){
       var minprice = parseInt(document.getElementById("minpriceSlider").value);
       var volume = parseInt(document.getElementById("volSlider").value);
       var maxprice = parseInt(document.getElementById("maxpriceSlider").value);
       var u_max;
       if('{{treatment}}' != 'flo'){ // use rate slider if flo
           u_max = parseInt({{max_u_max}});
       } else{
           u_max = parseInt(document.getElementById("rateSlider").value);
       }

       if(minprice > maxprice){
           alert("Minimum Price should be less than or equal to Maximum Price")
           return;
       }

       liveSend({
           'p_min': minprice,
           'p_max': maxprice,
           'q_max': volume,
           'u_max': u_max,
           'direction': 'sell',
           'status': 'active',
           'timestamp':performance.now()
       });

   };

   function new_buy_algo(){
       var minprice = parseInt(document.getElementById("algo-minpriceSlider").value);
       var volume = parseInt(document.getElementById("algo-volSlider").value);
       var maxprice = parseInt(document.getElementById("algo-maxpriceSlider").value);
       var time = parseInt(document.getElementById("algo-timeSlider").value);
       var quantity_per = parseInt(document.getElementById("algo-quantitySlider").value);
       var u_max;
       if('{{treatment}}' != 'flo'){ // use rate slider if flo
           u_max = parseInt({{max_u_max}});
       } else {
           u_max = parseInt(document.getElementById("algo-rateSlider").value);
       }


       if(minprice > maxprice){
           alert("Minimum Price should be less than or equal to Maximum Price")
           return;
       }

       liveSend({
           'p_min': minprice,
           'p_max': maxprice,
           'q_max': volume,
           'u_max': u_max,
           'expiration_time': time,
           'quantity_per': quantity_per,
           'direction': 'buy_algo',
           'status': 'active',
           'timestamp':performance.now()
       });
       order_id += 1;
   };

   function new_sell_algo(){
       var minprice = parseInt(document.getElementById("algo-minpriceSlider").value);
       var volume = parseInt(document.getElementById("algo-volSlider").value);
       var maxprice = parseInt(document.getElementById("algo-maxpriceSlider").value);
       var time = parseInt(document.getElementById("algo-timeSlider").value);
       var quantity_per = parseInt(document.getElementById("algo-quantitySlider").value);
       var u_max;
       if('{{treatment}}' != 'flo'){ // use rate slider if flo
           u_max = parseInt({{max_u_max}});
       } else{
           u_max = parseInt(document.getElementById("algo-rateSlider").value);
       }

       if(minprice > maxprice){
           alert("Minimum Price should be less than or equal to Maximum Price")
           return;
       }

       liveSend({
           'p_min': minprice,
           'p_max': maxprice,
           'q_max': volume,
           'u_max': u_max,
           'expiration_time': time,
           'quantity_per': quantity_per,
           'direction': 'sell_algo',
           'status': 'active',
           'timestamp':performance.now()
       });

   };
</script>

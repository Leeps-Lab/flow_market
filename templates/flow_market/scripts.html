{% load otree %}

<!--
            Code heavily adopted from Jason Vranek (github.com/JasonVranek)
        -->
<script type="module" src="{% static 'flow_market/market.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
<script src="https://code.highcharts.com/highcharts.js"></script>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.7.0/nouislider.min.js"
  integrity="sha512-jWNpWAWx86B/GZV4Qsce63q5jxx/rpWnw812vh0RE+SBIo/mmepwOSQkY2eVQnMuE28pzUEO7ux0a5sJX91g8A=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
></script>
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.7.0/nouislider.min.css"
  integrity="sha512-40vN6DdyQoxRJCw0klEUwZfTTlcwkOLKpP8K8125hy9iF4fi8gPpWZp60qKC6MYAFaond8yQds7cTMVU8eMbgA=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
/>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/wnumb/1.2.0/wNumb.min.js"
  integrity="sha512-igVQ7hyQVijOUlfg3OmcTZLwYJIBXU63xL9RC12xBHNpmGJAktDnzl9Iw0J4yrSaQtDxTTVlwhY730vphoVqJQ=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
></script>

{% block scripts %} {% include Constants.scripts_init_graphs_template %}
{%endblock %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
      if({{player.id_in_group}} == 1){
          liveSend({'direction': 'begin'});
          console.log("begin round");
      }
  }, false);
  const isCDA = '{{treatment}}' === 'cda';
  const isFLO = '{{treatment}}' === 'flo';
  const isFBA = '{{treatment}}' === 'fba';


   Chart.defaults.global.defaultFontFamily = 'Nunito';

  const graphs = init_graphs();
  const klf_line = graphs[2];
  const cash_bar = graphs[0];
  const inventory_bar = graphs[1];

  // Initialize the manual inputs
  const minpriceSliderVal = 6
  const maxpriceSliderVal = 10
  const volSliderVal = 50;
  const rateSliderVal = 3;

   const slider = document.getElementById('noUiPriceSlider');
   if (isCDA || isFBA) {
       noUiSlider.create(slider, {
           start: [maxpriceSliderVal],
           connect: true,
           pips: {
               mode: "count",
               values: 3,
               density: 10,

               {% comment %} mode: 'steps', {% endcomment %}
               {% comment %} density: 100, {% endcomment %}

               {% comment %} mode: 'range', {% endcomment %}
               {% comment %} density: 50 // DISCUSS {% endcomment %}
           },
           step: 1,
           tooltips: [
               wNumb({decimals: 0}),
           ],
           range: {
               'min': 1,
               'max': {{max_price}},
           },
       });
   } else if (isFLO) {
       noUiSlider.create(slider, {
           start: [minpriceSliderVal, maxpriceSliderVal],
           connect: true,
           pips: {
               mode: "count",
               values: 3,
               density: 10,

               {% comment %} mode: 'steps', {% endcomment %}
               {% comment %} density: 100, {% endcomment %}

               {% comment %} mode: 'range', {% endcomment %}
               {% comment %} density: 50 // DISCUSS {% endcomment %}
           },
           step: 1,
           tooltips: [
               wNumb({decimals: 0}),
               wNumb({decimals: 0}),
           ],
           range: {
               'min': 1,
               'max': {{max_price}},
           },
       });
   }
   slider.noUiSlider.on('change', () => {
       console.log("hello")
       console.log(slider.noUiSlider.get(true))

   });

   const noUiVolSlider = document.getElementById("noUiVolSlider")
   noUiSlider.create(noUiVolSlider, {
       start: [volSliderVal],
       connect: true,
       pips: {
           mode: 'values',
           values: [1, 50, {{max_q_max}}],
           density: 10
       },
       step: 1,
       tooltips: [
           wNumb({decimals: 0}),
       ],
       range: {
           'min': 1,
           'max': {{max_q_max}},
       },
   });


   const noUiRateSlider = document.getElementById("noUiRateSlider")
   noUiSlider.create(noUiRateSlider, {
       start: [volSliderVal],
       connect: true,
       pips: {
           mode: 'values',
           values: [1, 3, {{max_u_max}}],
           density: 30
       },
       step: 1,
       tooltips: [
           wNumb({decimals: 0}),
       ],
       range: {
           'min': 1,
           'max': {{max_u_max}},
       },
   });


  // Initialize the algorithm inputs
  // min="2" max="20" value="10"
  const algo_timeSliderVal = 3;

   const noUiAlgoTimeSlider = document.getElementById("noUiAlgoTimeSlider")
   noUiSlider.create(noUiAlgoTimeSlider, {
       start: [algo_timeSliderVal],
       connect: true,
       pips: {
           mode: 'values',
           values: [2, 10, 20],
           density: 10
       },
       step: 1,
       tooltips: [
           wNumb({decimals: 0}),
       ],
       range: {
           'min': 2,
           'max': 20,
       },
   });

  let algo_quantitySlider = document.getElementById("algo-quantitySlider");
  let algo_quantityValue = document.getElementById("algo-quantityValue");
  algo_quantitySlider.value = 10;
  algo_quantityValue.innerHTML = "Units at a time: " + algo_quantitySlider.value;
  algo_quantitySlider.oninput = function() {
      algo_quantityValue.innerHTML = "Units at a time: " + this.value;
  }

  let algo_minpriceSlider = document.getElementById("algo-minpriceSlider");
  let algo_minpriceValue = document.getElementById("algo-minpriceValue");
  algo_minpriceSlider.value = 10;
  algo_minpriceValue.innerHTML = "Min Price: " + algo_minpriceSlider.value;
  algo_minpriceSlider.oninput = function() {
      algo_minpriceValue.innerHTML = "Min Price: " + this.value;
  }

  let algo_maxpriceSlider = document.getElementById("algo-maxpriceSlider");
  let algo_maxpriceValue = document.getElementById("algo-maxpriceValue");
  algo_maxpriceSlider.value = 10;
  // From demo: in CDA, max price and min price are the same
  if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
      algo_maxpriceValue.innerHTML = "Price: " + algo_maxpriceSlider.value;
  } else {
      algo_maxpriceValue.innerHTML = "Max Price: " + algo_maxpriceSlider.value;
  }
  algo_maxpriceSlider.oninput = function() {
      if ('{{treatment}}' === 'cda' || '{{treatment}}' === 'fba') {
          // From demo: in CDA, max price and min price are the same
          console.log("minprice slider applied")
          algo_maxpriceValue.innerHTML = "Price: " + this.value;
          algo_minpriceValue.innerHTML = "Should be same as max Price: " + this.value;
          algo_minpriceSlider.value = this.value;
      } else {
          algo_maxpriceValue.innerHTML = "Max Price: " + this.value;
      }
  }

  let algo_volSlider = document.getElementById("algo-volSlider");
  let algo_volValue = document.getElementById("algo-volValue");
  algo_volSlider.value = 50;
  algo_volValue.innerHTML = "Max Volume: " + algo_volSlider.value;
  algo_volSlider.oninput = function() {
      algo_volValue.innerHTML = "Max Volume: " + this.value;
      console.log(`min: ${minpriceValue} max: ${maxpriceValue}`)
  }

  let algo_rateSlider = document.getElementById("algo-rateSlider");
  let algo_rateValue = document.getElementById("algo-rateValue");
  algo_rateSlider.value = 3;
  algo_rateValue.innerHTML = "Max Rate: " + algo_rateSlider.value;
  algo_rateSlider.oninput = function() {
      algo_rateValue.innerHTML = "Max Rate: " + this.value;
  }


  if ('{{treatment}}' != 'flo') {
      // Because cda and fba has a fixed u_max
      rateValue.remove();
      document.getElementById("rateValueWrapper").remove()
      document.getElementById("noUiRateSliderWrapper").remove()

      algo_rateSlider.remove();
      algo_rateValue.remove();
  }

  function calcDemand(buy, price) {
      if (price <= buy.p_min) {
          if (buy.q_max < buy.u_max) {
              // Don't trade more than q_max
              return buy.q_max;
          }
          // Trade at max rate if p <= p_min
          return buy.u_max;
      } else if (price > buy.p_max) {
          // Don't trade if price is higher than max willingness to buy
          return 0.0;
      } else {
          // The price fell p_min < price < p_max
          let trade_vol = buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
          if (trade_vol > buy.q_max) {
              // Saturate to q_max if trade_vol will exceed q_max
              return buy.q_max;
          }
          return trade_vol;
      }
  }

  function calcSupply(sell, price) {
      if (price < sell.p_min) {
          // Don't trade if price is lower than min willingness to sell
          return 0.0;
      } else if (price >= sell.p_max) {
          if (sell.q_max < sell.u_max) {
              // Don't trade more than q_max
              return sell.q_max;
          }
          // Trade at max rate if p >= p_max
          return sell.u_max;
      } else {
          // The price fell p_min < price < p_max
          let trade_vol = sell.u_max + ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
          if (trade_vol > sell.q_max) {
              // Saturate to q_max if trade_vol will exceed q_max
              return sell.q_max;
          }
          return trade_vol;
      }
  }

  function graphClearingPrice(chart, price, buys, sells) {
      buys = buys.filter(buy => buy['status'] == 'active');
      sells = sells.filter(sell => sell['status'] == 'active');
      var agg_supply = 0.0; // agg_supply will be equal to agg_demand
      sells.forEach(function (sell, _index, _array) {
              agg_supply += calcSupply(sell, price);
      });
      var points = [];

      points.push({x: 0.0, y: agg_supply});
      points.push({x: price, y: agg_supply});
      points.push({x: price, y: 0.0});

      chart.data.datasets[2].data = points;
      chart.update();
  }


  function graphBids(chart, buys) {
      buys = buys.filter(buy => buy['status'] == 'active');
      if('{{treatment}}' != 'cda'){ // TEST changes
          // READ
          // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply
          if (buys.length == 0) {
              chart.data.datasets[0].data = [];
              chart.update();
              return;
          }

          var points = [];

          // Generate range(70, 130) the domain based on sliders values
          // var prices = Array.from(new Array(0), (x,i) => i + 20);
          var prices = [...Array(20).keys()];
          prices.forEach(function (price, _index, _array) {
              var agg_supply = 0.0;
              buys.forEach(function (buy, _index, _array) {
                  agg_supply += calcDemand(buy, price);
              });
              points.push({x: price, y: agg_supply});
          });
      } else {
          // if treatment is cda, sort the buy orders,
          buys.sort((a, b) => (a['p_max'] < b['p_max']) ? 1 : -1);
          var volume = 0.0;
           var points = [];

           buys.forEach(function (buy, _index, _array) {
           // Graph (price, old_vol) -> (price, new_vol)
           points.push({x: buy['p_max'], y: volume});
           volume += buy['q_max'];
           points.push({x: buy['p_max'], y: volume});
       });

       // insert a horizontal line to 0 to show limit order
       points.push({x: 0.0, y: volume})
      }

      chart.data.datasets[0].data = points;
      chart.update();
  }

  function graphAsks(chart, sells) {
      sells = sells.filter(sell => sell['status'] == 'active');
      if('{{treatment}}' != 'cda'){ // TEST changes
          // READ
          if (sells.length == 0) {
              chart.data.datasets[1].data = [];
              chart.update();
              return;
          }

          var points = [];
          var prices = [...Array(20).keys()];
          prices.forEach(function (price, _index, _array) {
              var agg_supply = 0.0;
              sells.forEach(function (sell, _index, _array) {
                  agg_supply += calcSupply(sell, price);
              });
              points.push({x: price, y: agg_supply});
          });
      } else {
          sells.sort((a, b) => (a['p_max'] > b['p_max']) ? 1 : -1);
           var volume = 0.0;
           var points = [];
           sells.forEach(function (sell, _index, _array) {
               // Graph (price, old_vol) -> (price, new_vol)
               points.push({x: sell['p_max'], y: volume});
               volume += sell['q_max'];
               points.push({x: sell['p_max'], y: volume});
           });

           // insert a horizontal line to max price = 130 to show limit order
           points.push({x: 20.0, y: volume})
      }

      chart.data.datasets[1].data = points;
      chart.update();
  }

  // adds to the player's profit
  function updateProfit(chart, profit) {
      //chart.data.datasets[0].data[0] = profit;
      let dataset = chart.series[0];
      dataset.addPoint(profit);
      //chart.update();
  }

  // Adds or subtracts volume to trader
  function updateVolume(chart, volume) {
      //chart.data.datasets[0].data[0] = volume;
      let dataset = chart.series[0];
      dataset.addPoint(volume);
      //chart.update();
  }


  let order_id = 1;

  function liveRecv(data){
      if(data['type'] == 'begin'){
          console.log("Round begin");
      }
      if(data['type'] == 'clear'){
          klf_line.data.datasets[2].data = [];
          klf_line.update();
      }
      if(data['type'] == 'buy' || data['type'] == 'sell' || data['type'] == 'regraph'){
          console.log(data);
          graphBids(klf_line, data['buys']);
          graphAsks(klf_line, data['sells']);
      }
      if(data['type'] == 'clearing_price'){
          console.log(data);
          global_clearing_price = data['clearing_price'];
          // READ
          if('{{treatment}}' != 'cda') graphClearingPrice(klf_line, data['clearing_price'], data['buys'], data['sells']); // TEST changes
          graphBids(klf_line, data['buys']);
          graphAsks(klf_line, data['sells']);
      }
      if(data['type'] == 'update'){
          console.log(data);
          document.getElementById("cashInfo").innerHTML ="Cash " + Number.parseFloat(data['cash']).toFixed(2);
          document.getElementById("invInfo").innerHTML = "Inventory " + Number.parseFloat( data['inventory']).toFixed(2);
          updateProfit(cash_bar, data['cash']);
          updateVolume(inventory_bar, data['inventory']);
      }
  };



  function new_buy(){
      let maxprice;
      let minprice;
      if (isCDA || isFBA) {
           maxprice = parseInt(document.getElementById("noUiPriceSlider").noUiSlider.get())
           minprice = maxprice
      } else if (isFLO) {
           maxprice = parseInt(document.getElementById("noUiPriceSlider").noUiSlider.get()[1])
           minprice = parseInt(document.getElementById("noUiPriceSlider").noUiSlider.get()[0])
      }
      console.log("noUI buy", minprice, maxprice)

      const volume = parseInt(document.getElementById("noUiVolSlider").noUiSlider.get())

      var u_max;
      if('{{treatment}}' != 'flo'){ // use rate slider if flo
          u_max = parseInt({{max_u_max}});
      } else{
            u_max = parseInt(document.getElementById("noUiRateSlider").noUiSlider.get())
      }


      if(minprice > maxprice){
          alert("Minimum Price should be less than or equal to Maximum Price")
          return;
      }

      liveSend({
          'p_min': minprice,
          'p_max': maxprice,
          'q_max': volume,
          'u_max': u_max,
          'direction': 'buy',
          'status': 'active',
          'timestamp':performance.now()
      });
      order_id += 1;
  };

  function new_sell(){
      let maxprice;
      let minprice;
      if (isCDA || isFBA) {
           maxprice = parseInt(document.getElementById("noUiPriceSlider").noUiSlider.get())
           minprice = maxprice
      } else if (isFLO) {
           maxprice = parseInt(document.getElementById("noUiPriceSlider").noUiSlider.get()[1])
           minprice = parseInt(document.getElementById("noUiPriceSlider").noUiSlider.get()[0])
      }
      console.log("noUI sell", minprice, maxprice)

       const volume = parseInt(document.getElementById("noUiVolSlider").noUiSlider.get())

      let u_max;
      if('{{treatment}}' != 'flo'){ // use rate slider if flo
          u_max = parseInt({{max_u_max}});
      } else{
            u_max = parseInt(document.getElementById("noUiRateSlider").noUiSlider.get())
      }

      liveSend({
          'p_min': minprice,
          'p_max': maxprice,
          'q_max': volume,
          'u_max': u_max,
          'direction': 'sell',
          'status': 'active',
          'timestamp':performance.now()
      });

  };

  function new_buy_algo(){
      var minprice = parseInt(document.getElementById("algo-minpriceSlider").value);
      var volume = parseInt(document.getElementById("algo-volSlider").value);
      var maxprice = parseInt(document.getElementById("algo-maxpriceSlider").value);
      {% comment %} var time = parseInt(document.getElementById("algo-timeSlider").value); {% endcomment %}
        const time = parseInt(document.getElementById("noUiAlgoTimeSlider").noUiSlider.get())

      var quantity_per = parseInt(document.getElementById("algo-quantitySlider").value);
      var u_max;
      console.log({
       minprice,
       volume ,
       maxprice,
       time ,
       quantity_per,
       u_max,
      })

      if('{{treatment}}' != 'flo'){ // use rate slider if flo
          u_max = parseInt({{max_u_max}});
      } else {
          u_max = parseInt(document.getElementById("algo-rateSlider").value);
      }

      liveSend({
          'p_min': minprice,
          'p_max': maxprice,
          'q_max': volume,
          'u_max': u_max,
          'expiration_time': time,
          'quantity_per': quantity_per,
          'direction': 'buy_algo',
          'status': 'active',
          'timestamp':performance.now()
      });
      order_id += 1;
  };

  function new_sell_algo(){
      var minprice = parseInt(document.getElementById("algo-minpriceSlider").value);
      var volume = parseInt(document.getElementById("algo-volSlider").value);
      var maxprice = parseInt(document.getElementById("algo-maxpriceSlider").value);
      {% comment %} var time = parseInt(document.getElementById("algo-timeSlider").value); {% endcomment %}
        const time = parseInt(document.getElementById("noUiAlgoTimeSlider").noUiSlider.get())

      var quantity_per = parseInt(document.getElementById("algo-quantitySlider").value);
      var u_max;

      if('{{treatment}}' != 'flo'){ // use rate slider if flo
          u_max = parseInt({{max_u_max}});
      } else{
          u_max = parseInt(document.getElementById("algo-rateSlider").value);
      }

      liveSend({
          'p_min': minprice,
          'p_max': maxprice,
          'q_max': volume,
          'u_max': u_max,
          'expiration_time': time,
          'quantity_per': quantity_per,
          'direction': 'sell_algo',
          'status': 'active',
          'timestamp':performance.now()
      });

  };
</script>

{% load otree %}

<!--
            Code heavily adopted from Jason Vranek (github.com/JasonVranek)
        -->
<script type="module" src="{% static 'flow_market/market.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
<script src="https://code.highcharts.com/highcharts.js"></script>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.7.0/nouislider.min.js"
  integrity="sha512-jWNpWAWx86B/GZV4Qsce63q5jxx/rpWnw812vh0RE+SBIo/mmepwOSQkY2eVQnMuE28pzUEO7ux0a5sJX91g8A=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
></script>
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.7.0/nouislider.min.css"
  integrity="sha512-40vN6DdyQoxRJCw0klEUwZfTTlcwkOLKpP8K8125hy9iF4fi8gPpWZp60qKC6MYAFaond8yQds7cTMVU8eMbgA=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
/>
<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
/>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/wnumb/1.2.0/wNumb.min.js"
  integrity="sha512-igVQ7hyQVijOUlfg3OmcTZLwYJIBXU63xL9RC12xBHNpmGJAktDnzl9Iw0J4yrSaQtDxTTVlwhY730vphoVqJQ=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
></script>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuidv4.min.js"
  integrity="sha512-BCMqEPl2dokU3T/EFba7jrfL4FxgY6ryUh4rRC9feZw4yWUslZ3Uf/lPZ5/5UlEjn4prlQTRfIPYQkDrLCZJXA=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
></script>
<script src="//cdn.jsdelivr.net/npm/sweetalert2@11"></script>

{% block scripts %} {% include Constants.scripts_init_graphs_template %}
{%endblock %}
<script>
  // flo-- type: regraph, buys[0].status === "expired"
  document.addEventListener(
    'DOMContentLoaded',
    function () {
      if ('{{player.id_in_group}}' == 1) {
        liveSend({
          direction: 'begin',
        });
        console.log('begin round');
      }
    },
    false
  );

  const isCDA = '{{treatment}}' === 'cda';
  const isFLO = '{{treatment}}' === 'flo';
  const isFBA = '{{treatment}}' === 'fba';

  let orderHistory = [];

  // update order history if an order has expired
  function updateOrderHistory(data) {
    orderHistory = orderHistory.filter((order) => {
      let arrayToSearch;
      if (order.direction === 'buy') arrayToSearch = data.buys;
      if (order.direction === 'sell') arrayToSearch = data.sells;
      if (arrayToSearch === undefined) console.error('updateOrderHistory()');

      const orderInData = arrayToSearch.find((orderInData) => {
        return orderInData.orderID === order.orderID;
      });

      // BUG orderInData is sometimes undefined, not sure if due to liveserver delay with orderHistory
      if (orderInData === undefined) {
        console.error('orderInData undefined', order);
      }

      if (orderInData === undefined || orderInData.status === 'expired') {
        // also remove from active orders table
        removeActiveOrderTable(order.orderID);
        return false;
      } else {
        return true;
      }
    });
  }

  // check if potential order does not conflict with any orders in orderHistory
  function isNewOrderValid(newOrder) {
    if (orderHistory.length === 0) return undefined;

    // cda/fba: can only buy when buy's p_max < sell's p_max
    // cda/fba: can only sell when sell's p_max > buy's p_max
    let numToBeValid;
    if (isCDA || isFBA) {
      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_max < minPrice ? order.p_max : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }

      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_max > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }
    }

    // flo: can only sell when p_min is > buy's p_max
    // flo: can only buy when p_max < sell's p_min
    if (isFLO) {
      if (newOrder.direction === 'sell') {
        const maxPriceToBeat = orderHistory.reduce((maxPrice, order) => {
          if (order.direction === 'buy') {
            return order.p_max > maxPrice ? order.p_max : maxPrice;
          } else {
            return maxPrice;
          }
        }, Number.NEGATIVE_INFINITY);
        if (!(newOrder.p_min > maxPriceToBeat)) {
          numToBeValid = maxPriceToBeat;
        }
      }

      if (newOrder.direction === 'buy') {
        const minPriceToBeat = orderHistory.reduce((minPrice, order) => {
          if (order.direction === 'sell') {
            return order.p_min < minPrice ? order.p_min : minPrice;
          } else {
            return minPrice;
          }
        }, Number.POSITIVE_INFINITY);
        if (!(newOrder.p_max < minPriceToBeat)) {
          numToBeValid = minPriceToBeat;
        }
      }
    }

    return numToBeValid;
  }

  Chart.defaults.global.defaultFontFamily = 'Nunito';

  const graphs = init_graphs();
  const klf_line = graphs[2];
  const cash_bar = graphs[0];
  const inventory_bar = graphs[1];

  // Initialize the manual inputs
  const minpriceSliderVal = 6;
  const maxpriceSliderVal = 10;
  const volSliderVal = 50;
  const rateSliderVal = 3;

  const slider = document.getElementById('noUiPriceSlider');
  if (isCDA || isFBA) {
    noUiSlider.create(slider, {
      start: [maxpriceSliderVal],
      connect: [true, false],
      pips: {
        mode: 'count',
        values: 3,
        density: 10,
      },
      step: 1,
      tooltips: [
        wNumb({
          decimals: 0,
        }),
      ],
      range: {
        min: 1,
        max: parseInt('{{max_price}}'),
      },
    });
  } else if (isFLO) {
    noUiSlider.create(slider, {
      start: [minpriceSliderVal, maxpriceSliderVal],
      connect: true,
      pips: {
        mode: 'count',
        values: 3,
        density: 10,
      },
      step: 1,
      tooltips: [
        wNumb({
          decimals: 0,
        }),
        wNumb({
          decimals: 0,
        }),
      ],
      range: {
        min: 1,
        max: parseInt('{{max_price}}'),
      },
    });
  }

  const noUiVolSlider = document.getElementById('noUiVolSlider');
  noUiSlider.create(noUiVolSlider, {
    start: [volSliderVal],
    connect: [true, false],
    pips: {
      mode: 'values',
      values: [1, 50, parseInt('{{max_q_max}})')],
      density: 5,
    },
    step: 1,
    tooltips: [
      wNumb({
        decimals: 0,
      }),
    ],
    range: {
      min: 1,
      max: parseInt('{{max_q_max}}'),
    },
  });

  const noUiRateSlider = document.getElementById('noUiRateSlider');
  noUiSlider.create(noUiRateSlider, {
    start: [volSliderVal],
    connect: [true, false],
    pips: {
      mode: 'values',
      values: [1, 3, parseInt('{{max_u_max}}')],
      density: 30,
    },
    step: 1,
    tooltips: [
      wNumb({
        decimals: 0,
      }),
    ],
    range: {
      min: 1,
      max: parseInt('{{max_u_max}}'),
    },
  });

  // Initialize the algorithm inputs
  // min="2" max="20" value="10"
  const algo_timeSliderVal = 3;
  const algo_quantitySliderVal = 6;

  const noUiAlgoTimeSlider = document.getElementById('noUiAlgoTimeSlider');
  noUiSlider.create(noUiAlgoTimeSlider, {
    start: [algo_timeSliderVal],
    connect: [true, false],
    pips: {
      mode: 'count',
      values: 3,
      density: 10,
    },
    step: 1,
    tooltips: [
      wNumb({
        decimals: 0,
      }),
    ],
    range: {
      min: 2,
      max: 20,
    },
  });

  const noUiAlgoQuantitySlider = document.getElementById(
    'noUiAlgoQuantitySlider'
  );
  noUiSlider.create(noUiAlgoQuantitySlider, {
    start: [algo_quantitySliderVal],
    connect: [true, false],
    pips: {
      mode: 'count',
      values: 3,
      density: 10,
    },
    step: 1,
    tooltips: [
      wNumb({
        decimals: 0,
      }),
    ],
    range: {
      min: 1,
      max: 10,
    },
  });

  const noUiAlgoPriceSlider = document.getElementById('noUiAlgoPriceSlider');
  if (isCDA || isFBA) {
    noUiSlider.create(noUiAlgoPriceSlider, {
      start: [10],
      connect: [true, false],
      pips: {
        mode: 'count',
        values: 3,
        density: 10,
      },
      step: 1,
      tooltips: [
        wNumb({
          decimals: 0,
        }),
      ],
      range: {
        min: 1,
        max: parseInt('{{max_price}}'),
      },
    });
  } else if (isFLO) {
    noUiSlider.create(noUiAlgoPriceSlider, {
      start: [minpriceSliderVal, maxpriceSliderVal],
      connect: true,
      pips: {
        mode: 'count',
        values: 3,
        density: 10,
      },
      step: 1,
      tooltips: [
        wNumb({
          decimals: 0,
        }),
        wNumb({
          decimals: 0,
        }),
      ],
      range: {
        min: 1,
        max: parseInt('{{max_price}}'),
      },
    });
  }

  const noUiAlgoVolSlider = document.getElementById('noUiAlgoVolSlider');
  noUiSlider.create(noUiAlgoVolSlider, {
    start: [50],
    connect: [true, false],
    pips: {
      mode: 'values',
      values: [1, 50, parseInt('{{max_q_max}}')],
      density: 5,
    },
    step: 1,
    tooltips: [
      wNumb({
        decimals: 0,
      }),
    ],
    range: {
      min: 1,
      max: parseInt('{{max_q_max}}'),
    },
  });

  const noUiAlgoRateSlider = document.getElementById('noUiAlgoRateSlider');
  noUiSlider.create(noUiAlgoRateSlider, {
    start: [3],
    connect: [true, false],
    pips: {
      mode: 'count',
      values: 3,
      density: 30,
    },
    step: 1,
    tooltips: [
      wNumb({
        decimals: 0,
      }),
    ],
    range: {
      min: 1,
      max: parseInt('{{max_u_max}}'),
    },
  });

  if ('{{treatment}}' != 'flo') {
    // Because cda and fba has a fixed u_max
    document.querySelector('.noUiRateSliderWrapper').remove();
    document.querySelector('.noUiAlgoRateSliderWrapper').remove();
  }

  function calcDemand(buy, price) {
    if (price <= buy.p_min) {
      if (buy.q_max < buy.u_max) {
        // Don't trade more than q_max
        return buy.q_max;
      }
      // Trade at max rate if p <= p_min
      return buy.u_max;
    } else if (price > buy.p_max) {
      // Don't trade if price is higher than max willingness to buy
      return 0.0;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        buy.u_max * ((buy.p_max - price) / (buy.p_max - buy.p_min));
      if (trade_vol > buy.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return buy.q_max;
      }
      return trade_vol;
    }
  }

  function calcSupply(sell, price) {
    if (price < sell.p_min) {
      // Don't trade if price is lower than min willingness to sell
      return 0.0;
    } else if (price >= sell.p_max) {
      if (sell.q_max < sell.u_max) {
        // Don't trade more than q_max
        return sell.q_max;
      }
      // Trade at max rate if p >= p_max
      return sell.u_max;
    } else {
      // The price fell p_min < price < p_max
      let trade_vol =
        sell.u_max +
        ((price - sell.p_max) / (sell.p_max - sell.p_min)) * sell.u_max;
      if (trade_vol > sell.q_max) {
        // Saturate to q_max if trade_vol will exceed q_max
        return sell.q_max;
      }
      return trade_vol;
    }
  }

  function graphClearingPrice(chart, price, buys, sells) {
    buys = buys.filter((buy) => buy['status'] == 'active');
    sells = sells.filter((sell) => sell['status'] == 'active');
    var agg_supply = 0.0; // agg_supply will be equal to agg_demand
    sells.forEach(function (sell, _index, _array) {
      agg_supply += calcSupply(sell, price);
    });
    var points = [];

    points.push({
      x: 0.0,
      y: agg_supply,
    });
    points.push({
      x: price,
      y: agg_supply,
    });
    points.push({
      x: price,
      y: 0.0,
    });

    chart.data.datasets[2].data = points;
    chart.update();
  }

  function graphBids(chart, buys) {
    buys = buys.filter((buy) => buy['status'] == 'active');
    if ('{{treatment}}' != 'cda') {
      // TEST changes
      // READ
      // if treatment is fba/flo, calculate aggregate supply and graph x, y as price, aggregate supply
      if (buys.length == 0) {
        chart.data.datasets[0].data = [];
        chart.update();
        return;
      }

      var points = [];

      // Generate range(70, 130) the domain based on sliders values
      // var prices = Array.from(new Array(0), (x,i) => i + 20);
      var prices = [...Array(20).keys()];
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        buys.forEach(function (buy, _index, _array) {
          agg_supply += calcDemand(buy, price);
        });
        points.push({
          x: price,
          y: agg_supply,
        });
      });
    } else {
      // if treatment is cda, sort the buy orders,
      buys.sort((a, b) => (a['p_max'] < b['p_max'] ? 1 : -1));
      var volume = 0.0;
      var points = [];

      buys.forEach(function (buy, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: buy['p_max'],
          y: volume,
        });
        volume += buy['q_max'];
        points.push({
          x: buy['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to 0 to show limit order
      points.push({
        x: 0.0,
        y: volume,
      });
    }

    chart.data.datasets[0].data = points;
    chart.update();
  }

  function graphAsks(chart, sells) {
    sells = sells.filter((sell) => sell['status'] == 'active');
    if ('{{treatment}}' != 'cda') {
      // TEST changes
      // READ
      if (sells.length == 0) {
        chart.data.datasets[1].data = [];
        chart.update();
        return;
      }

      var points = [];
      var prices = [...Array(20).keys()];
      prices.forEach(function (price, _index, _array) {
        var agg_supply = 0.0;
        sells.forEach(function (sell, _index, _array) {
          agg_supply += calcSupply(sell, price);
        });
        points.push({
          x: price,
          y: agg_supply,
        });
      });
    } else {
      sells.sort((a, b) => (a['p_max'] > b['p_max'] ? 1 : -1));
      var volume = 0.0;
      var points = [];
      sells.forEach(function (sell, _index, _array) {
        // Graph (price, old_vol) -> (price, new_vol)
        points.push({
          x: sell['p_max'],
          y: volume,
        });
        volume += sell['q_max'];
        points.push({
          x: sell['p_max'],
          y: volume,
        });
      });

      // insert a horizontal line to max price = 130 to show limit order
      points.push({
        x: 20.0,
        y: volume,
      });
    }

    chart.data.datasets[1].data = points;
    chart.update();
  }

  // adds to the player's profit
  function updateProfit(chart, profit) {
    //chart.data.datasets[0].data[0] = profit;
    let dataset = chart.series[0];
    const profitFormatted = parseFloat(profit.toFixed(2));
    dataset.addPoint(profitFormatted);
    //chart.update();
  }

  // Adds or subtracts volume to trader
  function updateVolume(chart, volume) {
    //chart.data.datasets[0].data[0] = volume;
    let dataset = chart.series[0];
    const volumeFormated = parseFloat(volume.toFixed(2));
    dataset.addPoint(volumeFormated);
    //chart.update();
  }

  function liveRecv(data) {
    // console.log(data)
    if (data['type'] == 'begin') {
      console.log('Round begin');
    }
    if (data['type'] == 'clear') {
      // update cash and inventory bar regardless
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
      // clear book graph
      klf_line.data.datasets[2].data = [];
      klf_line.update();
    }
    // check if any orders in our orderHistory have expired
    // if so, then get rid of it
    if (data['type'] === 'regraph') {
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
      //   console.warn('should check if order has expired here', data);
      updateOrderHistory(data);
    }

    if (data['type'] == 'buy' || data['type'] == 'sell') {
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }
    if (data['type'] == 'clearing_price') {
      global_clearing_price = data['clearing_price'];
      // READ
      if ('{{treatment}}' != 'cda')
        graphClearingPrice(
          klf_line,
          data['clearing_price'],
          data['buys'],
          data['sells']
        ); // TEST changes
      graphBids(klf_line, data['buys']);
      graphAsks(klf_line, data['sells']);
    }
    if (data['type'] == 'update') {
      document.getElementById('cashInfo').innerHTML =
        'Cash ' + Number.parseFloat(data['cash']).toFixed(2);
      document.getElementById('invInfo').innerHTML =
        'Inventory ' + Number.parseFloat(data['inventory']).toFixed(2);
      updateProfit(cash_bar, data['cash']);
      updateVolume(inventory_bar, data['inventory']);
    }
  }

  function new_buy() {
    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
      );
    }

    const volume = parseInt(
      document.getElementById('noUiVolSlider').noUiSlider.get()
    );

    var u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiRateSlider').noUiSlider.get()
      );
    }

    if (minprice > maxprice) {
      alert('Minimum Price should be less than or equal to Maximum Price');
      return;
    }

    const order = {
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      direction: 'buy',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    // HERE implement checking logic
    const valueToBeat = isNewOrderValid(order); // undefined means order is valid
    if (valueToBeat === undefined) {
      orderHistory.push(order);
      appendActiveOrdersTable(order);

      //   console.log('frontend sending data:', order);

      liveSend(order);
    } else {
      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the price below ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your buy order will cross with one of your sell orders. Try decreasing the maximum price below ${valueToBeat}.`;
      }
      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });
    }
  }

  function new_sell() {
    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiPriceSlider').noUiSlider.get()[0]
      );
    }

    const volume = parseInt(
      document.getElementById('noUiVolSlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiRateSlider').noUiSlider.get()
      );
    }

    const order = {
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      direction: 'sell',
      status: 'active',
      timestamp: performance.now(),
      orderID: uuidv4(),
    };

    // HERE implement checking logic
    const valueToBeat = isNewOrderValid(order); // undefined means order is good
    if (valueToBeat === undefined) {
      orderHistory.push(order);
      appendActiveOrdersTable(order);
      //   console.log('frontend sending data:', order);
      liveSend(order);
    } else {
      let errorText;
      if (isCDA || isFBA) {
        // cda/fba: can only buy when buy's p_max < sell's p_max
        // cda/fba: can only sell when sell's p_max > buy's p_max
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the price above ${valueToBeat}.`;
      } else if (isFLO) {
        // flo: can only sell when p_min is > buy's p_max
        // flo: can only buy when p_max < sell's p_min
        errorText = `Your sell order will cross with one of your buy orders. Try increasing the minimum price above ${valueToBeat}.`;
      }
      Swal.fire({
        title: 'Cannot Trade With Yourself',
        icon: 'warning',
        text: errorText,
        showClass: {
          popup: 'animate__animated animate__fadeIn',
        },
      });
    }
  }

  function new_buy_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    /*
            console.log({
             minprice,
             volume ,
             maxprice,
             time ,
             quantity_per,
             u_max,
            })
            */

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'buy_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function new_sell_algo() {
    const volume = parseInt(
      document.getElementById('noUiAlgoVolSlider').noUiSlider.get()
    );
    const time = parseInt(
      document.getElementById('noUiAlgoTimeSlider').noUiSlider.get()
    );

    let maxprice;
    let minprice;
    if (isCDA || isFBA) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()
      );
      minprice = maxprice;
    } else if (isFLO) {
      maxprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[1]
      );
      minprice = parseInt(
        document.getElementById('noUiAlgoPriceSlider').noUiSlider.get()[0]
      );
    }

    const quantity_per = parseInt(
      document.getElementById('noUiAlgoQuantitySlider').noUiSlider.get()
    );

    let u_max;
    if ('{{treatment}}' != 'flo') {
      // use rate slider if flo
      u_max = parseInt('{{max_u_max}}');
    } else {
      u_max = parseInt(
        document.getElementById('noUiAlgoRateSlider').noUiSlider.get()
      );
    }

    /*
            console.log({
             minprice,
             volume ,
             maxprice,
             time ,
             quantity_per,
             u_max,
            })
            */

    liveSend({
      p_min: minprice,
      p_max: maxprice,
      q_max: volume,
      u_max: u_max,
      expiration_time: time,
      quantity_per: quantity_per,
      direction: 'sell_algo',
      status: 'active',
      timestamp: performance.now(),
      // TODO need to include uuid like in manual orders 'orderID': uuidv4()
    });
  }

  function debug() {
    console.log('orderHistory: ', orderHistory);
    appendActiveOrdersTable(null);
  }

  function appendActiveOrdersTable(order) {
    console.error(order);
    const table = document.querySelector('#activeOrdersTable');
    const newRow = document.createElement('tr');

    const direction = document.createElement('td');
    direction.innerHTML = order.direction === 'buy' ? 'Buy' : 'Sell';

    const price = document.createElement('td');
    price.innerHTML =
      order.p_min === order.p_max
        ? `${order.p_max}`
        : `${order.p_min}-${order.p_max}`;

    const quantity = document.createElement('td');
    quantity.innerHTML = order.q_max;

    direction.style.width = '91px';
    price.style.width = '61px';
    quantity.style.width = '88px';

    newRow.append(direction, price, quantity);
    // since id's cannot start with letter
    newRow.id = 'a' + order.orderID;
    // newRow.style.width = '326.4px';
    const tableWrapper = document.querySelector('#activeOrdersTableWrapper');

    table.appendChild(newRow);
  }

  if (isCDA || isFBA) {
    hideRateColumnActiveOrdersTable();
  }
  function removeActiveOrderTable(orderID) {
    document.querySelector(`#a${orderID}`).remove();
  }

  function hideRateColumnActiveOrdersTable() {
    document.querySelector('#activeOrdersRate').remove();
    document.querySelector('#activeOrdersDirection').style.width = '0';
  }
</script>
